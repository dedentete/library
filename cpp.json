{
    "BIT":{
        "prefix": "BIT",
        "body": [
            "template <typename T>",
            "struct BIT{",
            "    vector<T> dat;",
            "",
            "    BIT(int sz) : dat(sz + 1, 0) {}",
            "",
            "    T sum(int a){",
            "        T res = 0;",
            "        for(int i = a; i > 0; i -= (i & (-i))) res += dat[i];",
            "        return res;",
            "    }",
            "",
            "    T sum(int a, int b){",
            "        return sum(b - 1) - sum(a - 1);",
            "    }",
            "",
            "    void add(int k, T x){",
            "        for(int i = k; i <= dat.size(); i += (i & (-i))) dat[i] += x;",
            "    }",
            "};"
        ],
        "description": "BIT"
    },
    "LazySegmentTree":{
        "prefix": "LazySegmentTree",
        "body": [
            "/*",
            "    LazySegmentTree<ll, ll> seg(f, g, h, p, def, laz_def) のように宣言する",
            "    RMQ and RUQ の場合 : ",
            "    auto f = [](ll a, ll b){return min(a, b);};",
            "    auto g = [](ll a, ll b){return b;};",
            "    auto h = [](ll a, ll b){return b;};",
            "    auto p = [](ll a, ll b){return a;};",
            "    RSQ and RAQ の場合 : ",
            "    auto f = [](ll a, ll b){return a + b;};",
            "    auto g = [](ll a, ll b){return a + b;};",
            "    auto h = [](ll a, ll b){return a + b;};",
            "    auto p = [](ll a, int b){return a * b;};",
            "*/",
            "template <typename Monoid, typename OperatorMonoid>",
            "struct LazySegmentTree{",
            "    using F = function<Monoid(Monoid, Monoid)>;",
            "    using G = function<Monoid(Monoid, OperatorMonoid)>;",
            "    using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;",
            "    using P = function<OperatorMonoid(OperatorMonoid, int)>;",
            "    int n;",
            "    vector<Monoid> dat;",
            "    vector<OperatorMonoid> laz;",
            "    F f;",
            "    G g;",
            "    H h;",
            "    P p;",
            "    Monoid def;",
            "    OperatorMonoid laz_def;",
            "",
            "    LazySegmentTree(F f, G g, H h, P p, Monoid def, OperatorMonoid laz_def) : f(f), g(g), h(h), p(p), def(def), laz_def(laz_def){}",
            "",
            "    void build(const vector<Monoid> & vec){",
            "        int siz = vec.size();",
            "        n = 1;",
            "        while(n < siz) n *= 2;",
            "        dat.assign(2 * n - 1, def);",
            "        laz.assign(2 * n - 1, laz_def);",
            "        for(int i = 0; i < siz; i++) dat[n - 1 + i] = vec[i];",
            "        for(int i = n - 2; i >= 0; i--) dat[i] = f(dat[2 * i + 1], dat[2 * i + 2]);",
            "    }",
            "",
            "    void update(int a, int b, OperatorMonoid x){",
            "        update(a, b, x, 0, 0, n);",
            "    }",
            "",
            "    Monoid query(int a, int b){",
            "        return query(a, b, 0, 0, n);",
            "    }",
            "",
            "private:",
            "    void eval(int k, int l, int r){",
            "        if(laz[k] != laz_def){",
            "            dat[k] = g(dat[k], p(laz[k], r - l));",
            "            if(r - l > 1){",
            "                laz[2 * k + 1] = h(laz[2 * k + 1], laz[k]);",
            "                laz[2 * k + 2] = h(laz[2 * k + 2], laz[k]);",
            "            }",
            "            laz[k] = laz_def;",
            "        }",
            "    }",
            "",
            "    void update(int a, int b, OperatorMonoid x, int k, int l, int r){",
            "        eval(k, l, r);",
            "        if(r <= a || b <= l) return;",
            "        if(a <= l && r <= b){",
            "            laz[k] = h(laz[k], x);",
            "            eval(k, l, r);",
            "        }else{",
            "            update(a, b, x, 2 * k + 1, l, (l + r) / 2);",
            "            update(a, b, x, 2 * k + 2, (l + r) / 2, r);",
            "            dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);",
            "        }",
            "    }",
            "",
            "    Monoid query(int a, int b, int k, int l, int r){",
            "        if(r <= a || b <= l) return def;",
            "        eval(k, l, r);",
            "        if(a <= l && r <= b) return dat[k];",
            "        Monoid vl = query(a, b, 2 * k + 1, l, (l + r) / 2);",
            "        Monoid vr = query(a, b, 2 * k + 2, (l + r) / 2, r);",
            "        return f(vl, vr);",
            "    }",
            "};"
        ],
        "description": "LazySegmentTree"
    },
    "SegmentTree":{
        "prefix": "SegmentTree",
        "body": [
            "/*",
            "    SegmentTree<int> seg(f, def) のように宣言する",
            "    RMQ の場合 : ",
            "    auto f = [](int a, int b){return min(a, b);};",
            "    int def = INF;",
            "*/",
            "template <typename Monoid>",
            "struct SegmentTree{",
            "    using F = function<Monoid(Monoid, Monoid)>;",
            "    int n;",
            "    vector<Monoid> dat;",
            "    F f;",
            "    Monoid def;",
            "",
            "    SegmentTree(F f, Monoid def) : f(f), def(def) {}",
            "",
            "    void build(const vector<Monoid> & vec){",
            "        int sz = vec.size();",
            "        n = 1;",
            "        while(n < sz) n *= 2;",
            "        dat.assign(2 * n - 1, def);",
            "        for(int i = 0; i < sz; i++) dat[n - 1 + i] = vec[i];",
            "        for(int i = n - 2; i >= 0; i--) dat[i] = f(dat[2 * i + 1], dat[2 * i + 2]);",
            "    }",
            "",
            "    void update(int k, Monoid x){",
            "        k += (n - 1);",
            "        dat[k] = x;",
            "        while(k > 0){",
            "            k = (k - 1) / 2;",
            "            dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);",
            "        }",
            "    }",
            "",
            "    Monoid query(int a, int b){",
            "        return query(a, b, 0, 0, n);",
            "    }",
            "",
            "private:",
            "    Monoid query(int a, int b, int k, int l, int r){",
            "        if(r <= a || b <= l) return def;",
            "        if(a <= l && r <= b) return dat[k];",
            "        Monoid vl = query(a, b, 2 * k + 1, l, (l + r) / 2);",
            "        Monoid vr = query(a, b, 2 * k + 2, (l + r) / 2, r);",
            "        return f(vl, vr);",
            "    }",
            "};"
        ],
        "description": "SegmentTree"
    },
    "UnionFind":{
        "prefix": "UnionFind",
        "body": [
            "struct UnionFind{",
            "    vector<int> par;",
            "    vector<int> siz;",
            "",
            "    UnionFind(int n){",
            "        init(n);",
            "    }",
            "    ",
            "    void init(int n){",
            "        par.resize(n);",
            "        siz.resize(n);",
            "        for(int i = 0; i < n; i++){",
            "            par[i] = i;",
            "            siz[i] = 1;",
            "        }",
            "    }",
            "",
            "    int root(int x){",
            "        if(par[x] == x) return x;",
            "        else return par[x] = root(par[x]);",
            "    }",
            "",
            "    void unite(int x, int y){",
            "        x = root(x);",
            "        y = root(y);",
            "        if(x == y) return;",
            "        if(siz[x] < siz[y]) swap(x, y);",
            "        siz[x] += siz[y];",
            "        par[y] = x;",
            "    }",
            "",
            "    bool same(int x, int y){",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    int size(int x){",
            "        return siz[root(x)];",
            "    }",
            "};"
        ],
        "description": "UnionFind"
    },
    "RectangleSum":{
        "prefix": "RectangleSum",
        "body": [
            "template <typename T>",
            "struct RectangleSum{",
            "    vector<vector<T>> sum;",
            "",
            "    RectangleSum(int h, int w){",
            "        init(h, w);",
            "    }",
            "",
            "    void init(int h, int w){",
            "        sum.resize(h + 1, vector<T> (w + 1, 0));",
            "    }",
            "",
            "    void add(int y, int x, T val){",
            "        y++;",
            "        x++;",
            "        sum[y][x] += val;",
            "    }",
            "",
            "    void build(){",
            "        for(int i = 1; i < sum.size(); i++){",
            "            for(int j = 1; j < sum[i].size(); j++){",
            "                sum[i][j] += sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];",
            "            }",
            "        }",
            "    }",
            "",
            "    T getsum(int top, int left, int bottom, int right){//[top, bottom), [left, right)",
            "        return sum[bottom][right] - sum[bottom][left] - sum[top][right] + sum[top][left];",
            "    }",
            "};"
        ],
        "description": "RectangleSum"
    },
    "geometry":{
        "prefix": "geometry",
        "body": [
            "#define EPS (1e-10)",
            "#define equals(a, b) (fabs((a) - (b)) < EPS)",
            "",
            "struct Point {",
            "    double x, y;",
            "",
            "    Point(double x = 0, double y = 0) : x(x), y(y) {}",
            "    ",
            "    Point operator + (Point p) { return Point(x + p.x, y + p.y); }",
            "    Point operator - (Point p) { return Point(x - p.x, y - p.y); }",
            "    Point operator * (double a) { return Point(a * x, a * y); }",
            "    Point operator / (double a) { return Point(x / a, y / a); }",
            "",
            "    double abs() { return sqrt(norm()); }",
            "    double norm() { return x * x + y * y; }",
            "",
            "    bool operator < (const Point &p) const {",
            "        return x != p.x ? x < p.x : y < p.y;",
            "    }",
            "",
            "    bool operator == (const Point &p) const {",
            "        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;",
            "    }",
            "};",
            "",
            "typedef Point Vector;",
            "",
            "double norm(Vector a) { return a.x * a.x + a.y * a.y; }",
            "double abs(Vector a) { return sqrt(norm(a)); }",
            "double dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }",
            "double cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }",
            "",
            "struct Segment {",
            "    Point p1, p2;",
            "    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}",
            "};",
            "",
            "typedef Segment Line;",
            "",
            "struct Circle {",
            "    Point c;",
            "    double r;",
            "    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}",
            "};",
            "",
            "typedef vector<Point> Polygon;",
            "",
            "//直交判定",
            "bool isOrthogonal(Vector a, Vector b) {",
            "    return equals(dot(a, b), 0.0);",
            "}",
            "",
            "bool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {",
            "    return isOrthogonal(a1 - a2, b1 - b2);",
            "}",
            "",
            "bool isOrthogonal(Segment s1, Segment s2) {",
            "    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);",
            "}",
            "",
            "//平行判定",
            "bool isParallel(Vector a, Vector b) {",
            "    return equals(cross(a, b), 0.0);",
            "}",
            "",
            "bool isParallel(Point a1, Point a2, Point b1, Point b2) {",
            "    return isParallel(a1 - a2, b1 - b2);",
            "}",
            "",
            "bool isParallel(Segment s1, Segment s2) {",
            "    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);",
            "}",
            "",
            "//線分 s に点 p から垂線を引いた交点を求める",
            "Point project(Segment s, Point p) {",
            "    Vector base = s.p2 - s.p1;",
            "    double r = dot(p - s.p1, base) / norm(base);",
            "    return s.p1 + base * r;",
            "}",
            "",
            "//線分 s を対称軸として点 p と線対称の位置にある点を求める",
            "Point reflect(Segment s, Point p) {",
            "    return p + (project(s, p) - p) * 2.0;",
            "}",
            "",
            "double getDistance(Point a, Point b) {",
            "    return abs(a - b);",
            "}",
            "",
            "double getDistanceLP(Line l, Point p) {",
            "    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));",
            "}",
            "",
            "double getDistanceSP(Segment s, Point p) {",
            "    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);",
            "    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);",
            "    return getDistanceLP(s, p);",
            "}",
            "",
            "bool intersect(Segment s1, Segment s2);",
            "",
            "double getDistanceSS(Segment s1, Segment s2) {",
            "    if ( intersect(s1, s2) ) return 0.0;",
            "    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),",
            "               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));",
            "}",
            "",
            "static const int COUNTER_CLOCKWISE = 1;",
            "static const int CLOCKWISE = -1;",
            "static const int ONLINE_BACK = 2;",
            "static const int ONLINE_FRONT = -2;",
            "static const int ON_SEGMENT = 0;",
            "",
            "int ccw(Point p0, Point p1, Point p2) {",
            "    Vector a = p1 - p0;",
            "    Vector b = p2 - p0;",
            "    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;",
            "    if( cross(a, b) < -EPS ) return CLOCKWISE;",
            "    if( dot(a, b) < -EPS ) return ONLINE_BACK;",
            "    if( a.norm() < b.norm() ) return ONLINE_FRONT;",
            "",
            "    return ON_SEGMENT;",
            "}",
            "",
            "//交差判定",
            "bool intersect(Point p1, Point p2, Point p3, Point p4) {",
            "    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&",
            "             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );",
            "}",
            "",
            "bool intersect(Segment s1, Segment s2) {",
            "    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);",
            "}",
            "",
            "Point getCrossPointSS(Segment s1, Segment s2) {",
            "    Vector base = s2.p2 - s2.p1;",
            "    double d1 = abs(cross(base, s1.p1 - s2.p1));",
            "    double d2 = abs(cross(base, s1.p2 - s2.p1));",
            "    double t = d1 / (d1 + d2);",
            "    return s1.p1 + (s1.p2 - s1.p1) * t;",
            "}",
            "",
            "pair<Point, Point> getCrossPointCL(Circle c, Line l) {",
            "    // assert(intersect(c, l));",
            "    Vector pr = project(l, c.c);",
            "    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);",
            "    double base = sqrt(c.r * c.r - norm(pr - c.c));",
            "    return make_pair(pr + e * base, pr - e * base);",
            "}",
            "",
            "double arg(Vector p) { return atan2(p.y, p.x); }",
            "Vector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }",
            "",
            "pair<Point, Point> getCrossPointCC(Circle c1, Circle c2) {",
            "    // assert(intersect(c1, c2));",
            "    double d = abs(c1.c - c2.c);",
            "    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));",
            "    double t = arg(c2.c - c1.c);",
            "    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));",
            "}",
            "",
            "// IN : 2, ON : 1, OUT : 0",
            "int contains(Polygon g, Point p) {",
            "    int n = g.size();",
            "    bool x = false;",
            "    for( int i = 0; i < n; i++ ) {",
            "        Point a = g[i] - p, b = g[(i + 1) % n] - p;",
            "        if ( abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;",
            "        if ( a.y > b.y ) swap(a, b);",
            "        if ( a.y < EPS && EPS < b.y && cross(a, b) > EPS ) x = !x;",
            "    }",
            "    return ( x ? 2 : 0 );",
            "}"
        ],
        "description": "geometry"
    },
    "BellmanFord":{
        "prefix": "BellmanFord",
        "body": [
            "template <typename T>",
            "struct edge{",
            "    int from, to;",
            "    T cost;",
            "    edge(int from, int to, T cost = 1) : from(from), to(to), cost(cost){}",
            "    bool operator < (const edge & e) const{",
            "        return cost < e.cost;",
            "    }",
            "};",
            "",
            "/*",
            "    sからたどりつける負の閉路を検出したとき、空の vector を返す",
            "    頂点数 V, 始点 s, 辺の集合 es, INF として LINF を使うとき : ",
            "    vector<ll> dist = BellmanFord(V, s, es, LINF);",
            "*/",
            "template <typename T>",
            "vector<T> BellmanFord(int V, int s, vector<edge<T>> & es, const T INF = 1e9){",
            "    int E = es.size();",
            "    vector<T> dist(V, INF);",
            "    dist[s] = 0;",
            "    for(int i = 0; i < V - 1; i++){",
            "        for(edge<T> & e : es){",
            "            if(dist[e.from] == INF) continue;",
            "            dist[e.to] = min(dist[e.to], dist[e.from] + e.cost);",
            "        }",
            "    }",
            "    for(edge<T> & e : es){",
            "        if(dist[e.from] == INF) continue;",
            "        if(dist[e.from] + e.cost < dist[e.to]) return vector<T>();",
            "    }",
            "    return dist;",
            "}",
            "",
            "//グラフ全体をみて、負の閉路が存在するとき true を返す",
            "template <typename T>",
            "bool FindNegativeLoop(int V, vector<edge<T>> & es){",
            "    vector<T> dist(V, 0);",
            "    for(int i = 0; i < V; i++){",
            "        for(edge<T> & e : es){",
            "            if(dist[e.to] > dist[e.from] + e.cost){",
            "                dist[e.to] = dist[e.from] + e.cost;",
            "                if(i == V - 1) return true;",
            "            }",
            "        }",
            "    }",
            "    return false;",
            "}"
        ],
        "description": "BellmanFord"
    },
    "BipartiteMatching":{
        "prefix": "BipartiteMatching",
        "body": [
            "struct BiMatch{",
            "    int V, time;",
            "    vector<vector<int>> G;",
            "    vector<int> match, used;",
            "    vector<bool> dead;",
            "",
            "    BiMatch(int V) : V(V), time(0), G(V), match(V, -1), used(V, -1), dead(V, false) {} ",
            "",
            "    void add_edge(int u, int v){",
            "        G[u].emplace_back(v);",
            "        G[v].emplace_back(u);",
            "    }",
            "",
            "    bool dfs(int v){",
            "        used[v] = time;",
            "        for(int u : G[v]){",
            "            if(dead[u]) continue;",
            "            int w = match[u];",
            "            if((w < 0) || (used[w] < time && dfs(w))){",
            "                match[v] = u;",
            "                match[u] = v;",
            "                return true;",
            "            }",
            "        }",
            "        return false;",
            "    }",
            "",
            "    int build(){",
            "        int res = 0;",
            "        for(int v = 0; v < V; v++){",
            "            if(dead[v]) continue;",
            "            if(match[v] < 0){",
            "                time++;",
            "                res += dfs(v);",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "BipartiteMatching"
    },
    "Dijkstra":{
        "prefix": "Dijkstra",
        "body": [
            "template <typename T>",
            "vector<T> Dijkstra(int s, vector<vector<pair<int, T>>> & G, const T INF = 1e9){",
            "    using P = pair<T, int>;",
            "    int V = G.size();",
            "    vector<T> dist(V, INF);",
            "    priority_queue<P, vector<P>, greater<P>> que;",
            "    dist[s] = 0;",
            "    que.emplace(0, s);",
            "    while(!que.empty()){",
            "        P p = que.top();",
            "        que.pop();",
            "        int v = p.second;",
            "        if(dist[v] < p.first) continue;",
            "        for(int i = 0; i < G[v].size(); i++){",
            "            int to = G[v][i].first;",
            "            T cost = G[v][i].second;",
            "            if(dist[to] > dist[v] + cost){",
            "                dist[to] = dist[v] + cost;",
            "                que.emplace(dist[to], to);",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "Dijkstra"
    },
    "FordFulkerson":{
        "prefix": "FordFulkerson",
        "body": [
            "template <typename T>",
            "struct FordFulkerson{",
            "    struct edge{",
            "        int to;",
            "        T cap;",
            "        int rev;",
            "        edge(int to, T cap, int rev) : to(to), cap(cap), rev(rev) {}",
            "    };",
            "    ",
            "    vector<vector<edge>> G;",
            "    vector<bool> used;",
            "",
            "    FordFulkerson(int n) : G(n), used(n) {}",
            "",
            "    void add_edge(int from, int to, T cap){",
            "        G[from].emplace_back(to, cap, G[to].size());",
            "        G[to].emplace_back(from, 0, G[from].size() - 1);",
            "    }",
            "",
            "    T dfs(int v, int t, T f){",
            "        if(v == t) return f;",
            "        used[v] = true;",
            "        for(int i = 0; i < G[v].size(); i++){",
            "            edge & e = G[v][i];",
            "            if(!used[e.to] && e.cap > 0){",
            "                T d = dfs(e.to, t, min(f, e.cap));",
            "                if(d > 0){",
            "                    e.cap -= d;",
            "                    G[e.to][e.rev].cap += d;",
            "                    return d;",
            "                }",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    T flow(int s, int t, T INF = 1e9){",
            "        int fl = 0;",
            "        while(true){",
            "            fill(used.begin(), used.end(), false);",
            "            T f = dfs(s, t, INF);",
            "            if(f == 0) break;",
            "            fl += f;",
            "        }",
            "        return fl;",
            "    }",
            "};"
        ],
        "description": "FordFulkerson"
    },
    "Kruskal":{
        "prefix": "Kruskal",
        "body": [
            "struct UnionFind{",
            "    vector<int> par;",
            "    vector<int> siz;",
            "",
            "    UnionFind(int n){",
            "        init(n);",
            "    }",
            "    ",
            "    void init(int n){",
            "        par.resize(n);",
            "        siz.resize(n);",
            "        for(int i = 0; i < n; i++){",
            "            par[i] = i;",
            "            siz[i] = 1;",
            "        }",
            "    }",
            "",
            "    int root(int x){",
            "        if(par[x] == x) return x;",
            "        else return par[x] = root(par[x]);",
            "    }",
            "",
            "    void unite(int x, int y){",
            "        x = root(x);",
            "        y = root(y);",
            "        if(x == y) return;",
            "        if(siz[x] < siz[y]) swap(x, y);",
            "        siz[x] += siz[y];",
            "        par[y] = x;",
            "    }",
            "",
            "    bool same(int x, int y){",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    int size(int x){",
            "        return siz[root(x)];",
            "    }",
            "};",
            "",
            "template <typename T>",
            "struct edge{",
            "    int from, to;",
            "    T cost;",
            "    edge(int from, int to, T cost = 1) : from(from), to(to), cost(cost){}",
            "    bool operator < (const edge & e) const{",
            "        return cost < e.cost;",
            "    }",
            "};",
            "",
            "template <typename T>",
            "T Kruskal(int V, vector<edge<T>> & es){",
            "    sort(es.begin(), es.end()); //reverseすると最大全域木",
            "    UnionFind uf(V);",
            "    T res = 0;",
            "    for(edge<T> e : es){",
            "        if(!uf.same(e.from, e.to)){",
            "            uf.unite(e.from, e.to);",
            "            res += e.cost;",
            "        }",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Kruskal"
    },
    "TopologicalSort":{
        "prefix": "TopologicalSort",
        "body": [
            "vector<int> Tsort(vector<vector<int>> & G){",
            "    vector<int> To; //トポロジカルソート後のグラフ",
            "    // To.size() == V であればトポロジカルソートができた、そうでなければできなかったと判定できる",
            "    int V = G.size();",
            "    stack<int> st; //入次数が 0 の頂点の集合",
            "    int indeg[V] = {}; //頂点の入次数を管理する配列",
            "    for(int i = 0; i < V; i++){",
            "        for(int j = 0; j < G[i].size(); j++){",
            "            indeg[G[i][j]]++;",
            "        }",
            "    }",
            "    for(int i = 0; i < V; i++){",
            "        if(indeg[i] == 0){",
            "            st.push(i);",
            "        }",
            "    }",
            "    while(!st.empty()){",
            "        int u = st.top();",
            "        st.pop();",
            "        To.push_back(u);",
            "        for(int i = 0; i < G[u].size(); i++){",
            "            indeg[G[u][i]]--; //隣接する頂点の入次数を1減らす",
            "            //dp[G[u][i]] = max(dp[G[u][i]], dp[u] + 1);",
            "            //ans = max(ans, dp[G[u][i]]);",
            "            if(indeg[G[u][i]] == 0){",
            "                st.push(G[u][i]); //入次数が 0 になればstに追加",
            "            }",
            "        }",
            "    }",
            "    return To;",
            "}"
        ],
        "description": "TopologicalSort"
    },
    "WarshallFloyd":{
        "prefix": "WarshallFloyd",
        "body": [
            "/*",
            "    辺が存在しない場合、dist[i][j] = INF、ただしdist[i][i] = 0 とする",
            "    頂点数 V のとき : ",
            "    vector<vector<int>> dist(V, vector<int>(V, INF));",
            "    for(int i = 0; i < V; i++){",
            "        dist[i][i] = 0;",
            "    }",
            "*/",
            "template <typename T>",
            "void WarshallFloyd(vector<vector<T>> & dist){",
            "    int V = dist.size();",
            "    for(int k = 0; k < V; k++){",
            "        for(int i = 0; i < V; i++){",
            "            for(int j = 0; j < V; j++){",
            "                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);",
            "            }",
            "        }",
            "    }",
            "    // dist[i][i] < 0 が存在 <-> 負の閉路が存在",
            "}"
        ],
        "description": "WarshallFloyd"
    },
    "Combination":{
        "prefix": "Combination",
        "body": [
            "/*",
            "    MODint依存",
            "*/",
            "template <typename T>",
            "struct Comb{",
            "    vector<T> fac, fin;",
            "",
            "    Comb(int sz) : fac(sz + 1), fin(sz + 1){",
            "        fac[0] = fin[sz] = T(1);",
            "        for(int i = 1; i <= sz; i++){",
            "            fac[i] = fac[i - 1] * T(i);",
            "        }",
            "        fin[sz] /= fac[sz];",
            "        for(int i = sz - 1; i >= 0; i--){",
            "            fin[i] = fin[i + 1] * T(i + 1);",
            "        }",
            "    }",
            "",
            "    /* 階乗 */",
            "    inline T fact(int k) const { return fac[k]; }",
            "",
            "    inline T finv(int k) const { return fin[k]; }",
            "",
            "    /* 順列 */",
            "    T P(int n, int k) const {",
            "        if(k < 0 || n < k) return T(0);",
            "        return fac[n] * fin[n - k];",
            "    }",
            "",
            "    /* 組み合わせ */",
            "    T C(int n, int k) const {",
            "        if(k < 0 || n < k) return T(0);",
            "        return fac[n] * fin[n - k] * fin[k];",
            "    }",
            "",
            "    /* 重複組み合わせ */",
            "    T H(int n, int k) const {",
            "        if(n < 0 || k < 0) return T(0);",
            "        return k == 0 ? T(1) : C(n + k - 1, k);",
            "    }",
            "",
            "    /* ベル数 */",
            "    T B(int n, int k) const {",
            "        if(n == 0) return T(1);",
            "        k = min(k, n);",
            "        vector<T> dp(k + 1);",
            "        dp[0] = T(1);",
            "        for(int i = 1; i <= k; i++){",
            "            if(i & 1) dp[i] = dp[i - 1] - fin[i];",
            "            else dp[i] = dp[i - 1] + fin[i];",
            "        }",
            "        T res(0);",
            "        for(int i = 1; i <= k; i++){",
            "            /* MODint依存 */",
            "            res += T(i).pow(n) * fin[i] * dp[k - i];",
            "        }",
            "        return res;",
            "    }",
            "",
            "    /* スターリング数 */",
            "    T S(int n, int k) const {",
            "        T res(0);",
            "        for(int i = 1; i <= k; i++){",
            "            /* MODint依存 */",
            "            T t = C(k, i) * T(i).pow(n);",
            "            if((k - i) & 1) res -= t;",
            "            else res += t;",
            "        }",
            "        return res * fin[k];",
            "    }",
            "};",
            "",
            "/*",
            "    P(5, 3)の場合 : ",
            "    0 + 0 + 5 = 0 + 1 + 4 = 0 + 2 + 3 = 1 + 1 + 3 = 1 + 2 + 2",
            "    よって、P(5, 3) = 5",
            "*/",
            "template <typename T>",
            "struct Partition{",
            "    vector<vector<T>> dp;",
            "",
            "    Partition(int sz) : dp(sz + 1, vector<T>(sz + 1)){",
            "        dp[0][0] = T(1);",
            "        for(int i = 0; i <= sz; i++){",
            "            for(int j = 1; j <= sz; j++){",
            "                if(i - j >= 0) dp[i][j] = dp[i][j - 1] + dp[i - j][j];",
            "                else dp[i][j] = dp[i][j - 1];",
            "            }",
            "        }   ",
            "    }",
            "",
            "    /* 分割数 */",
            "    T P(int n, int k){",
            "        if(n < 0 || k < 0) return T(0);",
            "        return dp[n][k];",
            "    }",
            "};"
        ],
        "description": "Combination"
    },
    "divisor":{
        "prefix": "divisor",
        "body": [
            "vector<long long> divisor(long long n){",
            "    vector<long long> res;",
            "    for(int i = 1; (long long)i * i <= n; i++){",
            "        if(n % i == 0){",
            "            res.push_back(i);",
            "            if(i != n / i) res.push_back(n / i);",
            "        }",
            "    }",
            "    sort(begin(res), end(res));",
            "    return res;",
            "}"
        ],
        "description": "divisor"
    },
    "eratos":{
        "prefix": "eratos",
        "body": [
            "vector<bool> eratos(int n){",
            "    vector<bool> primes(n + 1, true);",
            "    primes[0] = primes[1] = false;",
            "    for(int i = 2; i * i <= n; i++){",
            "        if(!primes[i]) continue;",
            "        for(int j = i * i; j <= n; j += i){",
            "            primes[j] = false;",
            "        }",
            "    }",
            "    return primes;",
            "}"
        ],
        "description": "eratos"
    },
    "GCD":{
        "prefix": "GCD",
        "body": [
            "long long GCD(long long m, long long n){",
            "    if(n == 0) return m;",
            "    else return GCD(n, m % n);",
            "}"
        ],
        "description": "GCD"
    },
    "isPrime":{
        "prefix": "isPrime",
        "body": [
            "bool isPrime(long long n){",
            "    for(long long i = 2; i * i <= n; i++){",
            "        if(n % i == 0) return false;",
            "    }",
            "    return n != 1;",
            "}"
        ],
        "description": "isPrime"
    },
    "LCM":{
        "prefix": "LCM",
        "body": [
            "long long LCM(long long m, long long n){",
            "    long long g = GCD(m, n);",
            "    return m / g * n;",
            "}"
        ],
        "description": "LCM"
    },
    "Matrix":{
        "prefix": "Matrix",
        "body": [
            "/*",
            "    計算量...",
            "    和, 差 : O(N ^ 2)",
            "    積 : O(N ^ 3)",
            "    行列累乗(N ^ K) : O(N ^ 3 log K)",
            "*/",
            "template <typename T>",
            "struct Matrix{",
            "    typedef vector<vector<T>> mat;",
            "",
            "    mat A;",
            "",
            "    Matrix() {}",
            "    Matrix(int h, int w, T x = T(0)) : A(h, vector<T>(w, x) {}",
            "    Matrix(mat A) : A(A) {}",
            "",
            "    int size() const { return A.size(); }",
            "    const vector<T> & operator[] (int i) const { return A[i]; }",
            "    vector<T> & operator[] (int i) { return A[i]; }",
            "",
            "    Matrix & operator += (const Matrix & B){",
            "        assert(A.size() == B.size());",
            "        assert(A[0].size() == B[0].size());",
            "        for(int i = 0; i < A.size(); i++){",
            "            for(int j = 0; j < A[0].size(); j++){",
            "                A[i][j] += B[i][j];",
            "            }",
            "        }",
            "        return *this;",
            "    }",
            "",
            "    Matrix & operator -= (const Matrix & B){",
            "        assert(A.size() == B.size());",
            "        assert(A[0].size() == B[0].size());",
            "        for(int i = 0; i < A.size(); i++){",
            "            for(int j = 0; j < A[0].size(); j++){",
            "                A[i][j] -= B[i][j];",
            "            }",
            "        }",
            "        return *this;",
            "    }",
            "",
            "    Matrix & operator *= (const Matrix & B){",
            "        assert(A[0].size() == B.size());",
            "        int h = A.size(), w = B[0].size();",
            "        Matrix C(h, w);",
            "        for(int i = 0; i < h; i++){",
            "            for(int j = 0; j < w; j++){",
            "                for(int k = 0; k < B.size(); k++){",
            "                    C[i][j] += A[i][k] * B[k][j];",
            "                }",
            "            }",
            "        }",
            "        A.swap(C);",
            "        return *this;",
            "    }",
            "",
            "    Matrix operator + (const Matrix & B) const { return (Matrix(*this) += B); }",
            "    Matrix operator - (const Matrix & B) const { return (Matrix(*this) -= B); }",
            "    Matrix operator * (const Matrix & B) const { return (Matrix(*this) *= B); }",
            "",
            "    Matrix identity(int n){",
            "        Matrix E(n, n);",
            "        for(int i = 0; i < n; i++) E[i][i] = T(1);",
            "        return E;",
            "    }",
            "",
            "    Matrix pow(long long n){",
            "        Matrix B(A), C = identity(A.size());",
            "        while(n > 0){",
            "            if(n & 1) C *= B;",
            "            B *= B;",
            "            n >>= 1;",
            "        }",
            "        return C;",
            "    }",
            "};"
        ],
        "description": "Matrix"
    },
    "MODint":{
        "prefix": "MODint",
        "body": [
            "using ll = long long;",
            "template <ll MOD = 1000000007>",
            "struct Mint{",
            "    ll x;",
            "",
            "    Mint() : x(0) {}",
            "    Mint(ll t){",
            "        x = t % MOD;",
            "        if(x < 0) x += MOD;",
            "    }",
            "    ",
            "    Mint pow(ll n){",
            "        Mint res(1), t(x);",
            "        while(n > 0){",
            "            if(n & 1) res *= t;",
            "            t *= t;",
            "            n >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "",
            "    Mint inv() const {",
            "        ll a = x, b = MOD, u = 1, v = 0, t;",
            "        while(b > 0){",
            "            t = a / b;",
            "            a -= t * b;",
            "            swap(a, b);",
            "            u -= t * v;",
            "            swap(u, v);",
            "        }",
            "        return Mint(u);",
            "    }",
            "",
            "    Mint & operator += (Mint a){",
            "        x += a.x;",
            "        if(x >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    ",
            "    Mint & operator -= (Mint a){",
            "        x += MOD - a.x;",
            "        if(x >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "",
            "    Mint & operator *= (Mint a){",
            "        x = 1LL * x * a.x % MOD;",
            "        return *this;",
            "    }",
            "",
            "    Mint & operator /= (Mint a){",
            "        return (*this) *= a.inv();",
            "    }",
            "",
            "    Mint operator + (Mint a) const { return Mint(x) += a; }",
            "    Mint operator - (Mint a) const { return Mint(x) -= a; }",
            "    Mint operator * (Mint a) const { return Mint(x) *= a; }",
            "    Mint operator / (Mint a) const { return Mint(x) /= a; }",
            "",
            "    Mint operator - () const{ return Mint(-x); }",
            "",
            "    bool operator == (const Mint a){ return x == a.x; }",
            "    bool operator != (const Mint a){ return x != a.x; }",
            "    bool operator < (const Mint a){ return x < a.x; }",
            "",
            "    friend ostream & operator << (ostream & os, const Mint &a){",
            "        return os << a.x;",
            "    }",
            "",
            "    friend istream & operator >> (istream & is, Mint &a){",
            "        ll t;",
            "        is >> t;",
            "        a = Mint<MOD>(t);",
            "        return (is);",
            "    }",
            "};"
        ],
        "description": "MODint"
    },
    "MODpow":{
        "prefix": "MODpow",
        "body": [
            "template <typename T>",
            "T MODpow(T x, T n, T MOD = 1000000007) {",
            "    T res = 1;",
            "    while (n > 0) {",
            "        if (n & 1) res = res * x % MOD;",
            "        x = x * x % MOD;",
            "        n >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "MODpow"
    },
    "PrimeFactor":{
        "prefix": "PrimeFactor",
        "body": [
            "map<long long, int> PrimeFactor(long long n){",
            "    map<long long, int> mp;",
            "    for(int i = 2; (long long)i * i <= n; i++){",
            "        while(n % i == 0){",
            "            mp[i]++;",
            "            n /= i;",
            "        }",
            "    }",
            "    if(n != 1) mp[n]++;",
            "    return mp;",
            "}"
        ],
        "description": "PrimeFactor"
    },
    "SOD":{
        "prefix": "SOD",
        "body": [
            "long long SOD(long long n){",
            "    long long sum = 0;",
            "    while(n > 0){",
            "        sum += n % 10;",
            "        n /= 10;",
            "    }",
            "    return sum;",
            "}"
        ],
        "description": "SOD"
    },
    "compress":{
        "prefix": "compress",
        "body": [
            "/*",
            "    vector<long long> a(n) を座圧する場合 : ",
            "    auto v = compress(a);",
            "    auto m = dict(v);",
            "    i番目の要素の取り出し方 : ",
            "    m[a[i]]",
            "*/",
            "template<typename T>",
            "vector<T> compress(vector<T> vec){//ソートしてユニークを取ったvectorを返す",
            "    sort(vec.begin(), vec.end());",
            "    vec.erase(unique(vec.begin(), vec.end()), vec.end());",
            "    return vec;",
            "}",
            "",
            "template<typename T>",
            "map<T, int> dict(vector<T> & vec){//座圧する",
            "    map<T, int> res;",
            "    for(int i = 0; i < (int)vec.size(); i++){",
            "        res[vec[i]] = i;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "compress"
    },
    "RollingHash":{
        "prefix": "RollingHash",
        "body": [
            "/*",
            "    基数として乱数をとりたい場合 : ",
            "    ll MOD_1 = 1000000007, MOD_2 = 1000000009;",
            "    random_device rnd;",
            "    mt19937 mt(rnd());",
            "    B_1 = mt() % (MOD_1 - 2) + 2;",
            "    B_2 = mt() % (MOD_2 - 2) + 2;",
            "    RolligHash rh(s, B_1, B_2, MOD_1, MOD_2);",
            "*/",
            "struct RollingHash{",
            "    using T = long long;",
            "    using P = pair<T, T>;",
            "    T B_1, B_2, MOD_1, MOD_2;",
            "    vector<T> hash_1, hash_2, pow_1, pow_2;",
            "    ",
            "    RollingHash(string & s, T B_1 = 1007, T B_2 = 1009, T MOD_1 = 1000000007, T MOD_2 = 1000000009)",
            "     : B_1(B_1), B_2(B_2), MOD_1(MOD_1), MOD_2(MOD_2) {",
            "        int n = s.size();",
            "        hash_1.assign(n + 1, 0);",
            "        hash_2.assign(n + 1, 0);",
            "        pow_1.assign(n + 1, 1);",
            "        pow_2.assign(n + 1, 1);",
            "        for(int i = 0; i < n; i++){",
            "            hash_1[i + 1] = (hash_1[i] * B_1 + s[i]) % MOD_1;",
            "            hash_2[i + 1] = (hash_2[i] * B_2 + s[i]) % MOD_2;",
            "            pow_1[i + 1] = pow_1[i] * B_1 % MOD_1;",
            "            pow_2[i + 1] = pow_2[i] * B_2 % MOD_2;",
            "        }",
            "    }",
            "",
            "    P get(int l, int r){",
            "        T res_1 = ((hash_1[r] - hash_1[l] * pow_1[r - l]) % MOD_1 + MOD_1) % MOD_1;",
            "        T res_2 = ((hash_2[r] - hash_2[l] * pow_2[r - l]) % MOD_2 + MOD_2) % MOD_2;",
            "        return P(res_1, res_2);",
            "    }",
            "};"
        ],
        "description": "RollingHash"
    },
    "SuffixArray":{
        "prefix": "SuffixArray",
        "body": [
            "struct SuffixArray{",
            "    int n;",
            "    string s;",
            "    vector<int> sa;",
            "    ",
            "    SuffixArray(const string &s) : s(s) {",
            "        s.push_back('$');",
            "        sa.resize(n + 1);",
            "        iota(sa.begin(), sa.end(), 0);",
            "        sort(sa.begin(), sa.end(), [&](int a, int b){ if(s[a] == s[b]) return a > b; return s[a] < s[b]; });",
            "        vector<int> cs(n + 1, 0), rs(n + 1), cnt(n + 1);",
            "        for(int i = 0; i <= n; i++) rs[i] = s[i];",
            "        for(int len = 1; len <= n; len *= 2){",
            "            for(int i = 0; i <= n; i++){",
            "                cs[sa[i]] = i;",
            "                if(i > 0 && rs[sa[i - 1]] == rs[sa[i]] && sa[i - 1] + len <= n && rs[sa[i - 1] + len / 2] == rs[sa[i] + len / 2]) cs[sa[i]] = cs[sa[i - 1]];",
            "            }",
            "            iota(cnt.begin(), cnt.end(), 0);",
            "            copy(sa.begin(), sa.end(), rs.begin());",
            "            for(int i = 0; i <= n; i++){",
            "                int s1 = rs[i] - len;",
            "                if(s1 >= 0) sa[cnt[cs[s1]]++] = s1;",
            "            }",
            "            cs.swap(rs);",
            "        }",
            "    }",
            "",
            "    int operator[](int i) const{ return sa[i]; }",
            "",
            "    bool lt_substr(string & t, int si = 0, int ti = 0){",
            "        int sn = n, tn = t.size();",
            "        while(si < sn && ti < tn){",
            "            if(s[si] < t[ti]) return true;",
            "            if(s[si] > t[ti]) return false;",
            "            si++;",
            "            ti++;",
            "        }",
            "        return si >= sn && ti < tn;",
            "    }",
            "",
            "    int lower_bound(string & t){",
            "        int low = -1, high = n + 1;",
            "        while(high - low > 1){",
            "            int mid = (low + high) / 2;",
            "            if(lt_substr(t, sa[mid])) low = mid;",
            "            else high = mid;",
            "        }",
            "        return high;",
            "    }",
            "",
            "    int upper_bound(string & t){",
            "        t.back()++;",
            "        int res = lower_bound(t);",
            "        t.back()--;",
            "        return res;",
            "    }",
            "",
            "    int count(string & t){",
            "        return upper_bound(t) - lower_bound(t);",
            "    }",
            "};"
        ],
        "description": "SuffixArray"
    },
    "Zalgorithm":{
        "prefix": "Zalgorithm",
        "body": [
            "vector<int> Zalgorithm(string & s){",
            "    int n = s.size();",
            "    vector<int> res(n);",
            "    res[0] = n;",
            "    int i = 1, j = 0;",
            "    while(i < n){",
            "        while(i + j < n && s[j] == s[i + j]) j++;",
            "        res[i] = j;",
            "        if(j == 0){",
            "            i++;",
            "            continue;",
            "        }",
            "        int k = 1;",
            "        while(i + k < n && k + a[k] < j){",
            "            res[i + k] = res[k];",
            "            k++;",
            "        }",
            "        i += k;",
            "        j -= k;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Zalgorithm"
    },
    "main":{
        "prefix": "main",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define REP(i,a) for(int i = 0; i < (a); i++)",
            "#define ALL(a) (a).begin(),(a).end()",
            "typedef long long ll;",
            "typedef pair<int, int> P;",
            "const int INF = 1e9;",
            "const long long LINF = 1e18;",
            "const long long MOD = 1e9 + 7;",
            "",
            "signed main(){",
            "    $1",
            "    return 0;",
            "}"
        ],
        "description": "main"
    },
    "REP":{
        "prefix": "REP",
        "body": [
            "REP($1,$2){",
            "    $3",
            "}"
        ],
        "description": "REP"
    }
}