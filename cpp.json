{
    "BIT":{
        "prefix": "BIT",
        "body": [
            "template <typename T>",
            "struct BIT {",
            "    int n;",
            "    vector<T> dat;",
            "",
            "    BIT(int n) : n(n), dat(n + 1, 0) {}",
            "",
            "    T sum(int idx) {  // 1-indexed",
            "        T res(0);",
            "        for (int i = idx; i > 0; i -= i & -i) res += dat[i];",
            "        return res;",
            "    }",
            "",
            "    T sum(int l, int r) {  // 0-indexed",
            "        return sum(r) - sum(l);",
            "    }",
            "",
            "    void add(int idx, T x) {  // 0-indexed",
            "        idx++;",
            "        for (int i = idx; i <= n; i += i & -i) dat[i] += x;",
            "    }",
            "",
            "    int lower_bound(T x) {",
            "        if (x <= 0) return T(0);",
            "        int res = 0, r = 1;",
            "        while (r < n) r <<= 1;",
            "        for (; r > 0; r >>= 1) {",
            "            if (res + r <= n && dat[res + r] < x) {",
            "                x -= dat[res + r];",
            "                res += r;",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "    void print() {",
            "        for (int i = 0; i < n; i++) cout << sum(i, i + 1) << \" \";",
            "        cout << endl;",
            "    }",
            "};"
        ],
        "description": "BIT"
    },
    "ConvexHullTrick":{
        "prefix": "ConvexHullTrick",
        "body": [
            "// 追加クエリの傾き a が単調の場合しか使えない (単調でない場合は Li Chao Tree)",
            "template <typename T, bool isMin>",
            "struct CHT {",
            "#define F first",
            "#define S second",
            "    using P = pair<T, T>;",
            "    deque<P> H;",
            "",
            "    bool empty() const {",
            "        return H.empty();",
            "    }",
            "",
            "    void clear() {",
            "        H.clear();",
            "    }",
            "",
            "    inline int sgn(T x) {",
            "        return x == 0 ? 0 : (x < 0 ? -1 : 1);",
            "    }",
            "",
            "    inline bool check(const P& a, const P& b, const P& c) {",
            "        if (b.S == a.S || c.S == b.S)",
            "            return sgn(b.F - a.F) * sgn(c.S - b.S) >=",
            "                   sgn(c.F - b.F) * sgn(b.S - a.S);",
            "        return (long double)(b.F - a.F) * sgn(c.S - b.S) /",
            "                   (long double)(abs(b.S - a.S)) >=",
            "               (long double)(c.F - b.F) * sgn(b.S - a.S) /",
            "                   (long double)(abs(c.S - b.S));",
            "    }",
            "",
            "    void add(T a, T b) {",
            "        if (!isMin) a *= -1, b *= -1;",
            "        P line(a, b);",
            "        if (empty()) {",
            "            H.emplace_front(line);",
            "            return;",
            "        }",
            "        if (H.front().F <= a) {",
            "            if (H.front().F == a) {",
            "                if (H.front().S <= b) return;",
            "                H.pop_front();",
            "            }",
            "            while (H.size() > 1 && check(line, H.front(), H[1])) H.pop_front();",
            "            H.emplace_front(line);",
            "        } else {",
            "            assert(a <= H.back().F);",
            "            if (H.back().F == a) {",
            "                if (H.back().S <= b) return;",
            "                H.pop_back();",
            "            }",
            "            while (H.size() > 1 && check(H[H.size() - 2], H.back(), line))",
            "                H.pop_back();",
            "            H.emplace_back(line);",
            "        }",
            "    }",
            "",
            "    inline T getY(const P& a, const T& x) {",
            "        return a.F * x + a.S;",
            "    }",
            "",
            "    T query(T x) {",
            "        assert(!empty());",
            "        int l = -1, r = H.size() - 1;",
            "        while (r - l > 1) {",
            "            int m = (l + r) / 2;",
            "            if (getY(H[m], x) >= getY(H[m + 1], x))",
            "                l = m;",
            "            else",
            "                r = m;",
            "        }",
            "        if (isMin) return getY(H[r], x);",
            "        return -getY(H[r], x);",
            "    }",
            "};"
        ],
        "description": "ConvexHullTrick"
    },
    "DualSegmentTree":{
        "prefix": "DualSegmentTree",
        "body": [
            "// https://beet-aizu.github.io/library/segtree/basic/dual.cpp",
            "template <typename E>",
            "struct DualSegmentTree {",
            "    using H = function<E(E, E)>;",
            "    int n, height;",
            "    H h;",
            "    E ei;",
            "    vector<E> laz;",
            "",
            "    DualSegmentTree(H h, E ei) : h(h), ei(ei) {}",
            "",
            "    void init(int n_) {",
            "        n = 1;",
            "        height = 0;",
            "        while (n < n_) n <<= 1, height++;",
            "        laz.assign(2 * n, ei);",
            "    }",
            "",
            "    inline void propagate(int k) {",
            "        if (laz[k] == ei) return;",
            "        laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);",
            "        laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);",
            "        laz[k] = ei;",
            "    }",
            "",
            "    inline void thrust(int k) {",
            "        for (int i = height; i; i--) propagate(k >> i);",
            "    }",
            "",
            "    void update(int a, int b, E x) {",
            "        if (a >= b) return;",
            "        thrust(a += n);",
            "        thrust(b += n - 1);",
            "        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
            "            if (l & 1) laz[l] = h(laz[l], x), l++;",
            "            if (r & 1) --r, laz[r] = h(laz[r], x);",
            "        }",
            "    }",
            "",
            "    void update(int a, E x) {",
            "        thrust(a += n);",
            "        laz[a] = x;",
            "    }",
            "",
            "    E get(int a) {",
            "        thrust(a += n);",
            "        return laz[a];",
            "    }",
            "};"
        ],
        "description": "DualSegmentTree"
    },
    "LazySegmentTree":{
        "prefix": "LazySegmentTree",
        "body": [
            "/*",
            "    https://beet-aizu.github.io/library/segtree/basic/lazy.cpp",
            "    f : 要素と要素をマージする関数",
            "    g : 要素に作用素を作用させる関数",
            "    h : 作用素と作用素をマージする関数",
            "    ti : 要素の単位元",
            "    ei : 作用素の単位元",
            "",
            "    RMQ and RUQ ...",
            "    auto f = [](int a, int b) { return min(a, b); };",
            "    auto g = [](int a, int b) { return b; };",
            "    auto h = [](int a, int b) { return b; };",
            "    int ti = INT_MAX;",
            "    int ei = -1;",
            "*/",
            "template <typename T, typename E>",
            "struct LazySegmentTree {",
            "    using F = function<T(T, T)>;",
            "    using G = function<T(T, E)>;",
            "    using H = function<E(E, E)>;",
            "    int n, height;",
            "    F f;",
            "    G g;",
            "    H h;",
            "    T ti;",
            "    E ei;",
            "    vector<T> dat;",
            "    vector<E> laz;",
            "    LazySegmentTree(F f, G g, H h, T ti, E ei)",
            "        : f(f), g(g), h(h), ti(ti), ei(ei) {}",
            "",
            "    void init(int n_) {",
            "        n = 1;",
            "        height = 0;",
            "        while (n < n_) n <<= 1, height++;",
            "        dat.assign(2 * n, ti);",
            "        laz.assign(2 * n, ei);",
            "    }",
            "",
            "    void build(const vector<T> &v) {",
            "        int n_ = v.size();",
            "        init(n_);",
            "        for (int i = 0; i < n_; i++) dat[n + i] = v[i];",
            "        for (int i = n - 1; i; i--)",
            "            dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);",
            "    }",
            "",
            "    inline T reflect(int k) {",
            "        return laz[k] == ei ? dat[k] : g(dat[k], laz[k]);",
            "    }",
            "",
            "    inline void propagate(int k) {",
            "        if (laz[k] == ei) return;",
            "        laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);",
            "        laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);",
            "        dat[k] = reflect(k);",
            "        laz[k] = ei;",
            "    }",
            "",
            "    inline void thrust(int k) {",
            "        for (int i = height; i; i--) propagate(k >> i);",
            "    }",
            "",
            "    inline void recalc(int k) {",
            "        while (k >>= 1)",
            "            dat[k] = f(reflect((k << 1) | 0), reflect((k << 1) | 1));",
            "    }",
            "",
            "    void update(int a, int b, E x) {",
            "        if (a >= b) return;",
            "        thrust(a += n);",
            "        thrust(b += n - 1);",
            "        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
            "            if (l & 1) laz[l] = h(laz[l], x), l++;",
            "            if (r & 1) --r, laz[r] = h(laz[r], x);",
            "        }",
            "        recalc(a);",
            "        recalc(b);",
            "    }",
            "",
            "    void update(int a, T x) {",
            "        thrust(a += n);",
            "        dat[a] = x;",
            "        laz[a] = ei;",
            "        recalc(a);",
            "    }",
            "",
            "    T get(int a, int b) {",
            "        if (a >= b) return ti;",
            "        thrust(a += n);",
            "        thrust(b += n - 1);",
            "        T vl = ti, vr = ti;",
            "        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
            "            if (l & 1) vl = f(vl, reflect(l++));",
            "            if (r & 1) vr = f(reflect(--r), vr);",
            "        }",
            "        return f(vl, vr);",
            "    }",
            "",
            "    template <typename C>",
            "    int find(int st, C &check, T &acc, int k, int l, int r) {",
            "        if (l + 1 == r) {",
            "            acc = f(acc, reflect(k));",
            "            return check(acc) ? k - n : -1;",
            "        }",
            "        propagate(k);",
            "        int m = (l + r) >> 1;",
            "        if (m <= st) return find(st, check, acc, (k << 1) | 1, m, r);",
            "        if (st <= l and !check(f(acc, dat[k]))) {",
            "            acc = f(acc, dat[k]);",
            "            return -1;",
            "        }",
            "        int vl = find(st, check, acc, (k << 1) | 0, l, m);",
            "        if (~vl) return vl;",
            "        return find(st, check, acc, (k << 1) | 1, m, r);",
            "    }",
            "",
            "    template <typename C>",
            "    int find(int st, C &check) {",
            "        T acc = ti;",
            "        return find(st, check, acc, 1, 0, n);",
            "    }",
            "};"
        ],
        "description": "LazySegmentTree"
    },
    "SegmentTree":{
        "prefix": "SegmentTree",
        "body": [
            "// https://beet-aizu.github.io/library/segtree/basic/ushi.cpp",
            "template <typename T>",
            "struct SegmentTree {",
            "    using F = function<T(T, T)>;",
            "    int n;",
            "    F f;",
            "    T ti;",
            "    vector<T> dat;",
            "",
            "    SegmentTree(F f, T ti) : f(f), ti(ti) {}",
            "",
            "    void init(int n_) {",
            "        n = 1;",
            "        while (n < n_) n <<= 1;",
            "        dat.assign(n << 1, ti);",
            "    }",
            "",
            "    void build(const vector<T> &v) {",
            "        int n_ = v.size();",
            "        init(n_);",
            "        for (int i = 0; i < n_; i++) dat[n + i] = v[i];",
            "        for (int i = n - 1; i; i--)",
            "            dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);",
            "    }",
            "",
            "    void update(int k, T x) {",
            "        dat[k += n] = x;",
            "        while (k >>= 1) dat[k] = f(dat[(k << 1) | 0], dat[(k << 1) | 1]);",
            "    }",
            "",
            "    T get(int a, int b) {",
            "        if (a >= b) return ti;",
            "        T vl = ti, vr = ti;",
            "        for (int l = a + n, r = b + n; l < r; l >>= 1, r >>= 1) {",
            "            if (l & 1) vl = f(vl, dat[l++]);",
            "            if (r & 1) vr = f(dat[--r], vr);",
            "        }",
            "        return f(vl, vr);",
            "    }",
            "",
            "    template <typename C>",
            "    int find(int st, C &check, T &acc, int k, int l, int r) {",
            "        if (l + 1 == r) {",
            "            acc = f(acc, dat[k]);",
            "            return check(acc) ? k - n : -1;",
            "        }",
            "        int m = (l + r) >> 1;",
            "        if (m <= st) return find(st, check, acc, (k << 1) | 1, m, r);",
            "        if (st <= l and !check(f(acc, dat[k]))) {",
            "            acc = f(acc, dat[k]);",
            "            return -1;",
            "        }",
            "        int vl = find(st, check, acc, (k << 1) | 0, l, m);",
            "        if (~vl) return vl;",
            "        return find(st, check, acc, (k << 1) | 1, m, r);",
            "    }",
            "",
            "    template <typename C>",
            "    int find(int st, C &check) {",
            "        T acc = ti;",
            "        return find(st, check, acc, 1, 0, n);",
            "    }",
            "};"
        ],
        "description": "SegmentTree"
    },
    "UnionFind":{
        "prefix": "UnionFind",
        "body": [
            "struct UnionFind {",
            "    vector<int> par, siz;",
            "",
            "    UnionFind(int n) : par(n), siz(n, 1) {",
            "        iota(par.begin(), par.end(), 0);",
            "    }",
            "",
            "    int root(int x) {",
            "        if (par[x] == x)",
            "            return x;",
            "        else",
            "            return par[x] = root(par[x]);",
            "    }",
            "",
            "    void unite(int x, int y) {",
            "        x = root(x);",
            "        y = root(y);",
            "        if (x == y) return;",
            "        if (siz[x] < siz[y]) swap(x, y);",
            "        siz[x] += siz[y];",
            "        par[y] = x;",
            "    }",
            "",
            "    bool same(int x, int y) {",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    int size(int x) {",
            "        return siz[root(x)];",
            "    }",
            "};"
        ],
        "description": "UnionFind"
    },
    "WeightedUnionFind":{
        "prefix": "WeightedUnionFind",
        "body": [
            "template <typename T>",
            "struct WeightedUnionFind {",
            "    vector<int> par, siz;",
            "    vector<T> ws;",
            "",
            "    WeightedUnionFind(int n) : par(n), siz(n, 1), ws(n, T(0)) {",
            "        iota(par.begin(), par.end(), 0);",
            "    }",
            "",
            "    int root(int x) {",
            "        if (par[x] == x) return x;",
            "        int t = root(par[x]);",
            "        ws[x] += ws[par[x]];",
            "        return par[x] = t;",
            "    }",
            "",
            "    T weight(int x) {",
            "        root(x);",
            "        return ws[x];",
            "    }",
            "",
            "    void unite(int x, int y, T w) {",
            "        w += weight(x);",
            "        w -= weight(y);",
            "        x = root(x);",
            "        y = root(y);",
            "        if (x == y) return;",
            "        if (siz[x] < siz[y]) {",
            "            swap(x, y);",
            "            w = -w;",
            "        }",
            "        siz[x] += siz[y];",
            "        par[y] = x;",
            "        ws[y] = w;",
            "    }",
            "",
            "    bool same(int x, int y) {",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    int size(int x) {",
            "        return siz[root(x)];",
            "    }",
            "",
            "    T diff(int x, int y) {",
            "        return weight(y) - weight(x);",
            "    }",
            "};"
        ],
        "description": "WeightedUnionFind"
    },
    "RectangleSum":{
        "prefix": "RectangleSum",
        "body": [
            "template <typename T>",
            "struct RectangleSum {",
            "    vector<vector<T>> sum;",
            "",
            "    RectangleSum(int h, int w) {",
            "        init(h, w);",
            "    }",
            "",
            "    void init(int h, int w) {",
            "        sum.resize(h + 1, vector<T>(w + 1, 0));",
            "    }",
            "",
            "    void add(int y, int x, T val) {",
            "        y++;",
            "        x++;",
            "        sum[y][x] += val;",
            "    }",
            "",
            "    void build() {",
            "        for (int i = 1; i < (int)sum.size(); i++) {",
            "            for (int j = 1; j < (int)sum[i].size(); j++) {",
            "                sum[i][j] += sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];",
            "            }",
            "        }",
            "    }",
            "",
            "    T get(int top, int left, int bottom,",
            "          int right) {  //[top, bottom), [left, right)",
            "        return sum[bottom][right] - sum[bottom][left] - sum[top][right] +",
            "               sum[top][left];",
            "    }",
            "",
            "    void print() {",
            "        for (int y = 0; y < (int)sum.size() - 1; y++) {",
            "            for (int x = 0; x < (int)sum[y].size() - 1; x++) {",
            "                cout << get(y, x, y + 1, x + 1) << \" \";",
            "            }",
            "            cout << endl;",
            "        }",
            "    }",
            "};"
        ],
        "description": "RectangleSum"
    },
    "geometry":{
        "prefix": "geometry",
        "body": [
            "#define EPS (1e-10)",
            "#define equals(a, b) (fabs((a) - (b)) < EPS)",
            "",
            "struct Point {",
            "    double x, y;",
            "",
            "    Point(double x = 0, double y = 0) : x(x), y(y) {}",
            "",
            "    Point operator+(Point p) {",
            "        return Point(x + p.x, y + p.y);",
            "    }",
            "    Point operator-(Point p) {",
            "        return Point(x - p.x, y - p.y);",
            "    }",
            "    Point operator*(double a) {",
            "        return Point(a * x, a * y);",
            "    }",
            "    Point operator/(double a) {",
            "        return Point(x / a, y / a);",
            "    }",
            "",
            "    double abs() {",
            "        return sqrt(norm());",
            "    }",
            "    double norm() {",
            "        return x * x + y * y;",
            "    }",
            "",
            "    bool operator<(const Point &p) const {",
            "        return x != p.x ? x < p.x : y < p.y;",
            "    }",
            "",
            "    bool operator==(const Point &p) const {",
            "        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;",
            "    }",
            "};",
            "",
            "bool compX(Point a, Point b) {",
            "    return a.x != b.x ? a.x < b.x : a.y < b.y;",
            "}",
            "",
            "bool compY(Point a, Point b) {",
            "    return a.y != b.y ? a.y < b.y : a.x < b.x;",
            "}",
            "",
            "typedef Point Vector;",
            "",
            "double norm(Vector a) {",
            "    return a.x * a.x + a.y * a.y;",
            "}",
            "double abs(Vector a) {",
            "    return sqrt(norm(a));",
            "}",
            "double dot(Vector a, Vector b) {",
            "    return a.x * b.x + a.y * b.y;",
            "}",
            "double cross(Vector a, Vector b) {",
            "    return a.x * b.y - a.y * b.x;",
            "}",
            "",
            "struct Segment {",
            "    Point p1, p2;",
            "    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}",
            "};",
            "",
            "typedef Segment Line;",
            "",
            "struct Circle {",
            "    Point c;",
            "    double r;",
            "    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}",
            "};",
            "",
            "typedef vector<Point> Polygon;",
            "",
            "// 直交判定",
            "bool isOrthogonal(Vector a, Vector b) {",
            "    return equals(dot(a, b), 0.0);",
            "}",
            "",
            "bool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {",
            "    return isOrthogonal(a1 - a2, b1 - b2);",
            "}",
            "",
            "bool isOrthogonal(Segment s1, Segment s2) {",
            "    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);",
            "}",
            "",
            "// 平行判定",
            "bool isParallel(Vector a, Vector b) {",
            "    return equals(cross(a, b), 0.0);",
            "}",
            "",
            "bool isParallel(Point a1, Point a2, Point b1, Point b2) {",
            "    return isParallel(a1 - a2, b1 - b2);",
            "}",
            "",
            "bool isParallel(Segment s1, Segment s2) {",
            "    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);",
            "}",
            "",
            "// 線分 s に点 p から垂線を引いた交点を求める",
            "Point project(Segment s, Point p) {",
            "    Vector base = s.p2 - s.p1;",
            "    double r = dot(p - s.p1, base) / norm(base);",
            "    return s.p1 + base * r;",
            "}",
            "",
            "// 線分 s を対称軸として点 p と線対称の位置にある点を求める",
            "Point reflect(Segment s, Point p) {",
            "    return p + (project(s, p) - p) * 2.0;",
            "}",
            "",
            "double getDistance(Point a, Point b) {",
            "    return abs(a - b);",
            "}",
            "",
            "double getDistanceLP(Line l, Point p) {",
            "    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));",
            "}",
            "",
            "double getDistanceSP(Segment s, Point p) {",
            "    if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);",
            "    if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);",
            "    return getDistanceLP(s, p);",
            "}",
            "",
            "bool intersect(Segment s1, Segment s2);",
            "",
            "double getDistanceSS(Segment s1, Segment s2) {",
            "    if (intersect(s1, s2)) return 0.0;",
            "    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),",
            "               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));",
            "}",
            "",
            "static const int COUNTER_CLOCKWISE = 1;",
            "static const int CLOCKWISE = -1;",
            "static const int ONLINE_BACK = 2;",
            "static const int ONLINE_FRONT = -2;",
            "static const int ON_SEGMENT = 0;",
            "",
            "int ccw(Point p0, Point p1, Point p2) {",
            "    Vector a = p1 - p0;",
            "    Vector b = p2 - p0;",
            "    if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;",
            "    if (cross(a, b) < -EPS) return CLOCKWISE;",
            "    if (dot(a, b) < -EPS) return ONLINE_BACK;",
            "    if (a.norm() < b.norm()) return ONLINE_FRONT;",
            "",
            "    return ON_SEGMENT;",
            "}",
            "",
            "// 交差判定",
            "bool intersect(Point p1, Point p2, Point p3, Point p4) {",
            "    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&",
            "            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);",
            "}",
            "",
            "bool intersect(Segment s1, Segment s2) {",
            "    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);",
            "}",
            "",
            "Point getCrossPointSS(Segment s1, Segment s2) {",
            "    Vector base = s2.p2 - s2.p1;",
            "    double d1 = abs(cross(base, s1.p1 - s2.p1));",
            "    double d2 = abs(cross(base, s1.p2 - s2.p1));",
            "    double t = d1 / (d1 + d2);",
            "    return s1.p1 + (s1.p2 - s1.p1) * t;",
            "}",
            "",
            "pair<Point, Point> getCrossPointCL(Circle c, Line l) {",
            "    Vector pr = project(l, c.c);",
            "    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);",
            "    double base = sqrt(c.r * c.r - norm(pr - c.c));",
            "    return make_pair(pr + e * base, pr - e * base);",
            "}",
            "",
            "double arg(Vector p) {",
            "    return atan2(p.y, p.x);",
            "}",
            "Vector polar(double a, double r) {",
            "    return Point(cos(r) * a, sin(r) * a);",
            "}",
            "",
            "pair<Point, Point> getCrossPointCC(Circle c1, Circle c2) {",
            "    double d = abs(c1.c - c2.c);",
            "    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));",
            "    double t = arg(c2.c - c1.c);",
            "    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));",
            "}",
            "",
            "// IN : 2, ON : 1, OUT : 0",
            "int contains(Polygon g, Point p) {",
            "    int n = g.size();",
            "    bool x = false;",
            "    for (int i = 0; i < n; i++) {",
            "        Point a = g[i] - p, b = g[(i + 1) % n] - p;",
            "        if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;",
            "        if (a.y > b.y) swap(a, b);",
            "        if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;",
            "    }",
            "    return (x ? 2 : 0);",
            "}",
            "",
            "/*",
            "    凸法を生成",
            "    O(N log N)",
            "*/",
            "Polygon convexHull(Polygon g) {",
            "    int n = g.size();",
            "    sort(g.begin(), g.end(), compX);",
            "    int k = 0;",
            "    Polygon res(n * 2);",
            "    for (int i = 0; i < n; i++) {",
            "        while (k > 1 && cross(res[k - 1] - res[k - 2], g[i] - res[k - 1]) < 0)",
            "            k--;",
            "        res[k++] = g[i];",
            "    }",
            "    for (int i = n - 2, t = k; i >= 0; i--) {",
            "        while (k > t && cross(res[k - 1] - res[k - 2], g[i] - res[k - 1]) < 0)",
            "            k--;",
            "        res[k++] = g[i];",
            "    }",
            "    res.resize(k - 1);",
            "    return res;",
            "}",
            "",
            "/*",
            "    凸法の直径を求める",
            "    O(N log N)",
            "*/",
            "double convexDiameter(Polygon g) {",
            "    int n = g.size();",
            "    if (n == 2) return abs(g[0] - g[1]);",
            "    int i = 0, j = 0;",
            "    for (int k = 0; k < n; k++) {",
            "        if (g[i] < g[k]) i = k;",
            "        if (!(g[j] < g[k])) j = k;",
            "    }",
            "    double res = 0;",
            "    int si = i, sj = j;",
            "    while (i != sj || j != si) {",
            "        res = max(res, abs(g[i] - g[j]));",
            "        if (cross(g[(i + 1) % n] - g[i], g[(j + 1) % n] - g[j]) < 0.0) {",
            "            i = (i + 1) % n;",
            "        } else {",
            "            j = (j + 1) % n;",
            "        }",
            "    }",
            "    return res;",
            "}",
            "",
            "/*",
            "    最近点対を求める",
            "    O(N log N)",
            "*/",
            "double getClosestPair(Polygon &a, int l = 0, int r = -1) {",
            "    if (r < 0) {",
            "        r = a.size();",
            "        sort(a.begin(), a.end(), compX);",
            "    }",
            "    if (r - l <= 1) return abs(a[0] - a[1]);",
            "    int mid = (l + r) / 2;",
            "    double x = a[mid].x;",
            "    double d = min(getClosestPair(a, l, mid), getClosestPair(a, mid, r));",
            "    inplace_merge(a.begin() + l, a.begin() + mid, a.begin() + r, compY);",
            "",
            "    Polygon b;",
            "    for (int i = l; i < r; i++) {",
            "        if (abs(a[i].x - x) >= d) continue;",
            "        for (int j = 0; j < b.size(); j++) {",
            "            double dy = a[i].y - next(b.rbegin(), j)->y;",
            "            if (dy >= d) break;",
            "            d = min(d, abs(a[i] - *next(b.rbegin(), j)));",
            "        }",
            "        b.push_back(a[i]);",
            "    }",
            "    return d;",
            "}"
        ],
        "description": "geometry"
    },
    "BellmanFord":{
        "prefix": "BellmanFord",
        "body": [
            "template <typename T>",
            "struct edge {",
            "    int from, to;",
            "    T cost;",
            "    edge(int from, int to, T cost = 1) : from(from), to(to), cost(cost) {}",
            "    bool operator<(const edge& e) const {",
            "        return cost < e.cost;",
            "    }",
            "};",
            "",
            "/*",
            "    sからたどりつける負の閉路を検出したとき、空の vector を返す",
            "    頂点数 V, 始点 s, 辺の集合 es, INF として LINF を使うとき :",
            "    vector<ll> dist = BellmanFord(V, s, es, LINF);",
            "*/",
            "template <typename T>",
            "vector<T> BellmanFord(int V, int s, vector<edge<T>>& es) {",
            "    const T INF = numeric_limits<T>::max();",
            "    vector<T> dist(V, INF);",
            "    dist[s] = 0;",
            "    for (int i = 0; i < V - 1; i++) {",
            "        for (edge<T>& e : es) {",
            "            if (dist[e.from] == INF) continue;",
            "            dist[e.to] = min(dist[e.to], dist[e.from] + e.cost);",
            "        }",
            "    }",
            "    for (edge<T>& e : es) {",
            "        if (dist[e.from] == INF) continue;",
            "        if (dist[e.from] + e.cost < dist[e.to]) return vector<T>();",
            "    }",
            "    return dist;",
            "}",
            "",
            "//グラフ全体をみて、負の閉路が存在するとき true を返す",
            "template <typename T>",
            "bool FindNegativeLoop(int V, vector<edge<T>>& es) {",
            "    vector<T> dist(V, 0);",
            "    for (int i = 0; i < V; i++) {",
            "        for (edge<T>& e : es) {",
            "            if (dist[e.to] > dist[e.from] + e.cost) {",
            "                dist[e.to] = dist[e.from] + e.cost;",
            "                if (i == V - 1) return true;",
            "            }",
            "        }",
            "    }",
            "    return false;",
            "}"
        ],
        "description": "BellmanFord"
    },
    "BFS":{
        "prefix": "BFS",
        "body": [
            "vector<int> BFS(int s, vector<vector<int>>& G) {",
            "    int V = G.size();",
            "    vector<int> dist(V, -1);",
            "    queue<int> que;",
            "    que.emplace(s);",
            "    dist[s] = 0;",
            "    while (!que.empty()) {",
            "        int v = que.front();",
            "        que.pop();",
            "        for (int to : G[v]) {",
            "            if (dist[to] != -1) continue;",
            "            que.emplace(to);",
            "            dist[to] = dist[v] + 1;",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "BFS"
    },
    "BFS01":{
        "prefix": "BFS01",
        "body": [
            "vector<int> BFS01(int s, vector<vector<pair<int, int>>>& G,",
            "                  const int INF = 1e9) {",
            "    int V = G.size();",
            "    vector<int> dist(V, INF);",
            "    deque<int> que;",
            "    dist[s] = 0;",
            "    que.push_front(s);",
            "    while (!que.empty()) {",
            "        int v = que.front();",
            "        que.pop_front();",
            "        for (int i = 0; i < (int)G[v].size(); i++) {",
            "            int to = G[v][i].first, cost = G[v][i].second;",
            "            if (dist[to] != INF) continue;",
            "            if (cost == 1) {",
            "                que.push_back(to);",
            "                dist[to] = dist[v] + 1;",
            "            } else {",
            "                que.push_front(to);",
            "                dist[to] = dist[v];",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "BFS01"
    },
    "BipartiteMatching":{
        "prefix": "BipartiteMatching",
        "body": [
            "/*",
            "    二部グラフの最大マッチングを求める",
            "    O(VE)",
            "*/",
            "struct BiMatch {",
            "    int V, time;",
            "    vector<vector<int>> G;",
            "    vector<int> match, used;",
            "    vector<bool> dead;",
            "",
            "    BiMatch(int V)",
            "        : V(V), time(0), G(V), match(V, -1), used(V, -1), dead(V, false) {}",
            "",
            "    void add_edge(int u, int v) {",
            "        G[u].emplace_back(v);",
            "        G[v].emplace_back(u);",
            "    }",
            "",
            "    bool dfs(int v) {",
            "        used[v] = time;",
            "        for (int u : G[v]) {",
            "            if (dead[u]) continue;",
            "            int w = match[u];",
            "            if ((w < 0) || (used[w] < time && dfs(w))) {",
            "                match[v] = u;",
            "                match[u] = v;",
            "                return true;",
            "            }",
            "        }",
            "        return false;",
            "    }",
            "",
            "    int build() {",
            "        int res = 0;",
            "        for (int v = 0; v < V; v++) {",
            "            if (dead[v]) continue;",
            "            if (match[v] < 0) {",
            "                time++;",
            "                res += dfs(v);",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "BipartiteMatching"
    },
    "Dijkstra":{
        "prefix": "Dijkstra",
        "body": [
            "template <typename T>",
            "vector<T> Dijkstra(int s, vector<vector<pair<int, T>>>& G",
            "                   /*, vector<int> & prev*/) {",
            "    const T INF = numeric_limits<T>::max();",
            "    using P = pair<T, int>;",
            "    int V = G.size();",
            "    vector<T> dist(V, INF);",
            "    priority_queue<P, vector<P>, greater<P>> que;",
            "    dist[s] = 0;",
            "    que.emplace(0, s);",
            "    // prev.assign(V, -1);",
            "    while (!que.empty()) {",
            "        P p = que.top();",
            "        que.pop();",
            "        int v = p.second;",
            "        if (dist[v] < p.first) continue;",
            "        for (int i = 0; i < (int)G[v].size(); i++) {",
            "            int to = G[v][i].first;",
            "            T cost = G[v][i].second;",
            "            if (dist[to] > dist[v] + cost) {",
            "                dist[to] = dist[v] + cost;",
            "                // prev[to] = v;",
            "                que.emplace(dist[to], to);",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "Dijkstra"
    },
    "FordFulkerson":{
        "prefix": "FordFulkerson",
        "body": [
            "/*",
            "    最大流 O(FE)",
            "    有向グラフであることに注意 !",
            "*/",
            "template <typename T>",
            "struct FordFulkerson {",
            "    struct edge {",
            "        int to;",
            "        T cap;",
            "        int rev;",
            "        edge(int to, T cap, int rev) : to(to), cap(cap), rev(rev) {}",
            "    };",
            "",
            "    vector<vector<edge>> G;",
            "    vector<bool> used;",
            "",
            "    FordFulkerson(int n) : G(n), used(n) {}",
            "",
            "    void add_edge(int from, int to, T cap) {",
            "        G[from].emplace_back(to, cap, G[to].size());",
            "        G[to].emplace_back(from, 0, G[from].size() - 1);",
            "    }",
            "",
            "    T dfs(int v, int t, T f) {",
            "        if (v == t) return f;",
            "        used[v] = true;",
            "        for (edge& e : G[v]) {",
            "            if (!used[e.to] && e.cap > 0) {",
            "                T d = dfs(e.to, t, min(f, e.cap));",
            "                if (d > 0) {",
            "                    e.cap -= d;",
            "                    G[e.to][e.rev].cap += d;",
            "                    return d;",
            "                }",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    T flow(int s, int t, T INF = 1e9) {",
            "        T fl = 0;",
            "        while (true) {",
            "            fill(used.begin(), used.end(), false);",
            "            T f = dfs(s, t, INF);",
            "            if (f == 0) break;",
            "            fl += f;",
            "        }",
            "        return fl;",
            "    }",
            "};"
        ],
        "description": "FordFulkerson"
    },
    "gridBFS":{
        "prefix": "gridBFS",
        "body": [
            "vector<vector<int>> gridBFS(vector<string>& s, int sy, int sx, char wall = '#',",
            "                            const int INF = 1e9) {",
            "    const int dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0};",
            "    int h = s.size(), w = s[0].size();",
            "    vector<vector<int>> dist(h, vector<int>(w, INF));",
            "    queue<pair<int, int>> que;",
            "    que.emplace(sy, sx);",
            "    dist[sy][sx] = 0;",
            "    while (!que.empty()) {",
            "        pair<int, int> p = que.front();",
            "        que.pop();",
            "        for (int i = 0; i < 4; i++) {",
            "            int ny = p.first + dy[i], nx = p.second + dx[i];",
            "            if (0 <= ny && ny < h && 0 <= nx && nx < w && s[ny][nx] != wall &&",
            "                dist[ny][nx] == INF) {",
            "                que.emplace(ny, nx);",
            "                dist[ny][nx] = dist[p.first][p.second] + 1;",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "gridBFS"
    },
    "Kruskal":{
        "prefix": "Kruskal",
        "body": [
            "struct UnionFind {",
            "    vector<int> par, siz;",
            "",
            "    UnionFind(int n) : par(n), siz(n, 1) {",
            "        iota(par.begin(), par.end(), 0);",
            "    }",
            "",
            "    int root(int x) {",
            "        if (par[x] == x)",
            "            return x;",
            "        else",
            "            return par[x] = root(par[x]);",
            "    }",
            "",
            "    void unite(int x, int y) {",
            "        x = root(x);",
            "        y = root(y);",
            "        if (x == y) return;",
            "        if (siz[x] < siz[y]) swap(x, y);",
            "        siz[x] += siz[y];",
            "        par[y] = x;",
            "    }",
            "",
            "    bool same(int x, int y) {",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    int size(int x) {",
            "        return siz[root(x)];",
            "    }",
            "};",
            "",
            "template <typename T>",
            "struct edge {",
            "    int from, to;",
            "    T cost;",
            "    edge(int from, int to, T cost = 1) : from(from), to(to), cost(cost) {}",
            "    bool operator<(const edge& e) const {",
            "        return cost < e.cost;",
            "    }",
            "};",
            "",
            "template <typename T>",
            "T Kruskal(int V, vector<edge<T>>& es) {",
            "    sort(es.begin(), es.end());  // reverseすると最大全域木",
            "    UnionFind uf(V);",
            "    T res = 0;",
            "    for (edge<T> e : es) {",
            "        if (!uf.same(e.from, e.to)) {",
            "            uf.unite(e.from, e.to);",
            "            res += e.cost;",
            "        }",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Kruskal"
    },
    "MultiBFS":{
        "prefix": "MultiBFS",
        "body": [
            "vector<int> MultiBFS(vector<int> vs, vector<vector<int>>& G) {",
            "    int V = G.size();",
            "    vector<int> dist(V, -1);",
            "    queue<int> que;",
            "    for (int s : vs) {",
            "        que.emplace(s);",
            "        dist[s] = 0;",
            "    }",
            "    while (!que.empty()) {",
            "        int v = que.front();",
            "        que.pop();",
            "        for (int to : G[v]) {",
            "            if (dist[to] != -1) continue;",
            "            que.emplace(to);",
            "            dist[to] = dist[v] + 1;",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "MultiBFS"
    },
    "PrimalDual":{
        "prefix": "PrimalDual",
        "body": [
            "/*",
            "    最小費用流 O(FElogV)",
            "    有向グラフであることに注意 !",
            "*/",
            "template <typename FT, typename CT>",
            "struct PrimalDual {",
            "    struct edge {",
            "        int to;",
            "        FT cap;",
            "        CT cost;",
            "        int rev;",
            "        edge(int to, FT cap, CT cost, int rev)",
            "            : to(to), cap(cap), cost(cost), rev(rev) {}",
            "    };",
            "",
            "    const CT INF;",
            "    vector<vector<edge>> G;",
            "    vector<CT> h, dist;",
            "    vector<int> prevv, preve;",
            "",
            "    PrimalDual(int n, CT INF = 1e9)",
            "        : G(n), h(n), dist(n), prevv(n), preve(n), INF(INF) {}",
            "",
            "    void add_edge(int u, int v, FT cap, CT cost) {",
            "        G[u].emplace_back(v, cap, cost, G[v].size());",
            "        G[v].emplace_back(u, 0, -cost, G[u].size() - 1);",
            "    }",
            "",
            "    void Dijkstra(int s) {",
            "        using P = pair<CT, int>;",
            "        priority_queue<P, vector<P>, greater<P>> que;",
            "        fill(dist.begin(), dist.end(), INF);",
            "        dist[s] = 0;",
            "        que.emplace(0, s);",
            "        while (!que.empty()) {",
            "            P p = que.top();",
            "            que.pop();",
            "            int v = p.second;",
            "            if (dist[v] < p.first) continue;",
            "            for (int i = 0; i < (int)G[v].size(); i++) {",
            "                edge& e = G[v][i];",
            "                if (e.cap == 0) continue;",
            "                if (dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {",
            "                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];",
            "                    prevv[e.to] = v;",
            "                    preve[e.to] = i;",
            "                    que.emplace(dist[e.to], e.to);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    CT flow(int s, int t, FT f) {",
            "        CT res = 0;",
            "        fill(h.begin(), h.end(), 0);",
            "        while (f > 0) {",
            "            Dijkstra(s);",
            "            if (dist[t] == INF) return -1;",
            "            for (int v = 0; v < (int)h.size(); v++) {",
            "                if (dist[v] < INF) h[v] = h[v] + dist[v];",
            "            }",
            "            FT d = f;",
            "            for (int v = t; v != s; v = prevv[v]) {",
            "                d = min(d, G[prevv[v]][preve[v]].cap);",
            "            }",
            "            f -= d;",
            "            res = res + h[t] * d;",
            "            for (int v = t; v != s; v = prevv[v]) {",
            "                edge& e = G[prevv[v]][preve[v]];",
            "                e.cap -= d;",
            "                G[v][e.rev].cap += d;",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "PrimalDual"
    },
    "StronglyConnectedComponent":{
        "prefix": "StronglyConnectedComponent",
        "body": [
            "struct SCC {",
            "    int n, cnt;",
            "    vector<vector<int>> G, R;",
            "    vector<bool> used;",
            "    vector<int> vs, cmp;",
            "",
            "    SCC(int n) : n(n), G(n), R(n), used(n), cmp(n) {}",
            "",
            "    int operator[](int k) {",
            "        return cmp[k];",
            "    };",
            "",
            "    void add_edge(int from, int to) {",
            "        G[from].emplace_back(to);",
            "        R[to].emplace_back(from);",
            "    }",
            "",
            "    void dfs(int v) {",
            "        used[v] = true;",
            "        for (int u : G[v]) {",
            "            if (!used[u]) dfs(u);",
            "        }",
            "        vs.emplace_back(v);",
            "    }",
            "",
            "    void rdfs(int v, int cnt) {",
            "        used[v] = true;",
            "        cmp[v] = cnt;",
            "        for (int u : R[v]) {",
            "            if (!used[u]) rdfs(u, cnt);",
            "        }",
            "    }",
            "",
            "    int build() {",
            "        for (int v = 0; v < n; v++) {",
            "            if (!used[v]) dfs(v);",
            "        }",
            "        fill(used.begin(), used.end(), false);",
            "        cnt = 0;",
            "        for (int i = n - 1; i >= 0; i--) {",
            "            if (!used[vs[i]]) {",
            "                rdfs(vs[i], cnt);",
            "                cnt++;",
            "            }",
            "        }",
            "        return cnt;",
            "    }",
            "",
            "    vector<vector<int>> makeGraph() {",
            "        vector<vector<int>> res;",
            "        res.resize(cnt, vector<int>());",
            "        for (int v = 0; v < n; v++) {",
            "            for (int u : G[v]) {",
            "                if (cmp[v] != cmp[u]) res[cmp[v]].emplace_back(cmp[u]);",
            "            }",
            "        }",
            "        for (int i = 0; i < cnt; i++) {",
            "            sort(res[i].begin(), res[i].end());",
            "            res[i].erase(unique(res[i].begin(), res[i].end()), res[i].end());",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "StronglyConnectedComponent"
    },
    "TopologicalSort":{
        "prefix": "TopologicalSort",
        "body": [
            "/*",
            "    To.size() == V",
            "   であればトポロジカルソートができた、そうでなければできなかったと判定できる",
            "*/",
            "vector<int> Tsort(vector<vector<int>>& G) {",
            "    vector<int> To;",
            "    int V = G.size();",
            "    stack<int> st;",
            "    int indeg[V] = {};",
            "    for (int i = 0; i < V; i++) {",
            "        for (int j = 0; j < G[i].size(); j++) {",
            "            indeg[G[i][j]]++;",
            "        }",
            "    }",
            "    for (int i = 0; i < V; i++) {",
            "        if (indeg[i] == 0) {",
            "            st.push(i);",
            "        }",
            "    }",
            "    // vector<int> dp(V);",
            "    while (!st.empty()) {",
            "        int u = st.top();",
            "        st.pop();",
            "        To.push_back(u);",
            "        for (int i = 0; i < G[u].size(); i++) {",
            "            indeg[G[u][i]]--;",
            "            // dp[G[u][i]] = max(dp[G[u][i]], dp[u] + 1);",
            "            // ans = max(ans, dp[G[u][i]]);",
            "            if (indeg[G[u][i]] == 0) {",
            "                st.push(G[u][i]);",
            "            }",
            "        }",
            "    }",
            "    return To;",
            "}"
        ],
        "description": "TopologicalSort"
    },
    "TSP":{
        "prefix": "TSP",
        "body": [
            "template <typename T>",
            "T TSP(int s, vector<vector<pair<int, T>>>& G) {",
            "    const T INF = numeric_limits<T>::max() / 2;",
            "    int V = G.size();",
            "    vector<vector<T>> dp(1 << V, vector<T>(V, INF));",
            "    dp[0][s] = 0;",
            "    for (int bit = 0; bit < 1 << V; bit++) {",
            "        for (int v = 0; v < V; v++) {",
            "            for (auto p : G[v]) {",
            "                int to = p.first, dist = p.second;",
            "                if (bit & 1 << to) continue;",
            "                dp[bit | 1 << to][to] =",
            "                    min(dp[bit | 1 << to][to], dp[bit][v] + dist);",
            "            }",
            "        }",
            "    }",
            "    return dp[(1 << V) - 1][s];",
            "}"
        ],
        "description": "TSP"
    },
    "WarshallFloyd":{
        "prefix": "WarshallFloyd",
        "body": [
            "/*",
            "    辺が存在しない場合、dist[i][j] = INF、ただしdist[i][i] = 0 とする",
            "    頂点数 V のとき :",
            "    vector<vector<int>> dist(V, vector<int>(V, INF));",
            "    for(int i = 0; i < V; i++){",
            "        dist[i][i] = 0;",
            "    }",
            "*/",
            "template <typename T>",
            "void WarshallFloyd(vector<vector<T>>& dist) {",
            "    int V = dist.size();",
            "    for (int k = 0; k < V; k++) {",
            "        for (int i = 0; i < V; i++) {",
            "            for (int j = 0; j < V; j++) {",
            "                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);",
            "            }",
            "        }",
            "    }",
            "    // dist[i][i] < 0 が存在 <-> 負の閉路が存在",
            "}"
        ],
        "description": "WarshallFloyd"
    },
    "SimulatedAnnealing":{
        "prefix": "SimulatedAnnealing",
        "body": [
            "constexpr double TIMELIMIT = 1.9;",
            "",
            "struct XorShift {",
            "    unsigned int x, y, z, w, t;",
            "",
            "    XorShift(int seed) {",
            "        mt19937 rnd(seed);",
            "        x = rnd();",
            "        y = rnd();",
            "        z = rnd();",
            "        w = rnd();",
            "        t = 1;",
            "    }",
            "",
            "    int rand() {",
            "        t = x ^ (x << 11);",
            "        x = y;",
            "        y = z;",
            "        z = w;",
            "        w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));",
            "        return w & 0x7fffffff;",
            "    }",
            "} rnd(rand());",
            "",
            "struct Timer {",
            "    chrono::system_clock::time_point start, now;",
            "",
            "    Timer() {",
            "        start = chrono::system_clock::now();",
            "    }",
            "",
            "    double getTime() {",
            "        now = chrono::system_clock::now();",
            "        return chrono::duration<double>(now - start).count();",
            "    }",
            "};",
            "",
            "struct State {",
            "    int score;",
            "};",
            "",
            "constexpr int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};",
            "",
            "void calc(State& state) {",
            "    ",
            "}",
            "",
            "void init(State& state) {",
            "    ",
            "    calc(state);",
            "}",
            "",
            "void modify(State& state) {",
            "    ",
            "    calc(state);",
            "}",
            "",
            "void solve(State& state) {",
            "    int steps = 0;",
            "    Timer tmr;",
            "    double nowclock;",
            "    double startclock = tmr.getTime();",
            "    // double starttemp, endtemp;",
            "    while (true) {",
            "        nowclock = tmr.getTime();",
            "        if (nowclock - startclock > TIMELIMIT) break;",
            "        State newstate = state;",
            "        modify(newstate);",
            "        if (newstate.score > state.score) {",
            "            state = newstate;",
            "        }",
            "        /*",
            "        double temp = starttemp + (endtemp - starttemp) *",
            "                                      (nowclock - startclock) / TIMELIMIT;",
            "        double prob = exp((newstate.score - state.score) / temp);",
            "        if (prob > (rnd.rand() % (int)1e9) / 1e9) {",
            "            state = newstate;",
            "        }",
            "        */",
            "        steps++;",
            "    }",
            "    cerr << \"score : \" << state.score << endl;",
            "    cerr << \"steps : \" << steps << endl;",
            "}"
        ],
        "description": "SimulatedAnnealing"
    },
    "Timer":{
        "prefix": "Timer",
        "body": [
            "struct Timer {",
            "    chrono::system_clock::time_point start, now;",
            "",
            "    Timer() {",
            "        start = chrono::system_clock::now();",
            "    }",
            "",
            "    double getTime() {",
            "        now = chrono::system_clock::now();",
            "        return chrono::duration<double>(now - start).count();",
            "    }",
            "};"
        ],
        "description": "Timer"
    },
    "Xorshift":{
        "prefix": "Xorshift",
        "body": [
            "struct XorShift {",
            "    unsigned int x, y, z, w, t;",
            "",
            "    XorShift(int seed) {",
            "        mt19937 rnd(seed);",
            "        x = rnd();",
            "        y = rnd();",
            "        z = rnd();",
            "        w = rnd();",
            "        t = 1;",
            "    }",
            "",
            "    int rand() {",
            "        t = x ^ (x << 11);",
            "        x = y;",
            "        y = z;",
            "        z = w;",
            "        w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));",
            "        return w & 0x7fffffff;",
            "    }",
            "} rnd(rand());"
        ],
        "description": "Xorshift"
    },
    "Combination":{
        "prefix": "Combination",
        "body": [
            "// MODint依存",
            "template <typename T>",
            "struct Comb {",
            "    vector<T> fac, fin;",
            "",
            "    Comb(int sz) : fac(sz + 1), fin(sz + 1) {",
            "        fac[0] = fin[sz] = T(1);",
            "        for (int i = 1; i <= sz; i++) {",
            "            fac[i] = fac[i - 1] * T(i);",
            "        }",
            "        fin[sz] /= fac[sz];",
            "        for (int i = sz - 1; i >= 0; i--) {",
            "            fin[i] = fin[i + 1] * T(i + 1);",
            "        }",
            "    }",
            "",
            "    // 階乗",
            "    inline T fact(int k) const {",
            "        return fac[k];",
            "    }",
            "",
            "    inline T finv(int k) const {",
            "        return fin[k];",
            "    }",
            "",
            "    // 順列",
            "    T P(int n, int k) const {",
            "        if (k < 0 || n < k) return T(0);",
            "        return fac[n] * fin[n - k];",
            "    }",
            "",
            "    // 組み合わせ",
            "    T C(int n, int k) const {",
            "        if (k < 0 || n < k) return T(0);",
            "        return fac[n] * fin[n - k] * fin[k];",
            "    }",
            "",
            "    // 重複組み合わせ",
            "    T H(int n, int k) const {",
            "        if (n < 0 || k < 0) return T(0);",
            "        return k == 0 ? T(1) : C(n + k - 1, k);",
            "    }",
            "",
            "    // ベル数",
            "    T B(int n, int k) const {",
            "        if (n == 0) return T(1);",
            "        k = min(k, n);",
            "        vector<T> dp(k + 1);",
            "        dp[0] = T(1);",
            "        for (int i = 1; i <= k; i++) {",
            "            if (i & 1)",
            "                dp[i] = dp[i - 1] - fin[i];",
            "            else",
            "                dp[i] = dp[i - 1] + fin[i];",
            "        }",
            "        T res(0);",
            "        for (int i = 1; i <= k; i++) {",
            "            // MODint依存",
            "            res += T(i).pow(n) * fin[i] * dp[k - i];",
            "        }",
            "        return res;",
            "    }",
            "",
            "    // スターリング数",
            "    T S(int n, int k) const {",
            "        T res(0);",
            "        for (int i = 1; i <= k; i++) {",
            "            // MODint依存",
            "            T t = C(k, i) * T(i).pow(n);",
            "            if ((k - i) & 1)",
            "                res -= t;",
            "            else",
            "                res += t;",
            "        }",
            "        return res * fin[k];",
            "    }",
            "};",
            "",
            "/*",
            "    P(5, 3)の場合 :",
            "    0 + 0 + 5 = 0 + 1 + 4 = 0 + 2 + 3 = 1 + 1 + 3 = 1 + 2 + 2",
            "    よって、P(5, 3) = 5",
            "*/",
            "template <typename T>",
            "struct Partition {",
            "    vector<vector<T>> dp;",
            "",
            "    Partition(int sz) : dp(sz + 1, vector<T>(sz + 1)) {",
            "        dp[0][0] = T(1);",
            "        for (int i = 0; i <= sz; i++) {",
            "            for (int j = 1; j <= sz; j++) {",
            "                if (i - j >= 0)",
            "                    dp[i][j] = dp[i][j - 1] + dp[i - j][j];",
            "                else",
            "                    dp[i][j] = dp[i][j - 1];",
            "            }",
            "        }",
            "    }",
            "",
            "    //分割数",
            "    T P(int n, int k) {",
            "        if (n < 0 || k < 0) return T(0);",
            "        return dp[n][k];",
            "    }",
            "};",
            "",
            "/*",
            "    MODint依存",
            "    計算量 : O(k)",
            "*/",
            "template <typename T>",
            "T C(long long n, int k) {",
            "    T num(1), denom(1);",
            "    for (int i = 0; i < k; i++) {",
            "        num *= T(n - i);",
            "        denom *= T(i + 1);",
            "    }",
            "    return num / denom;",
            "}"
        ],
        "description": "Combination"
    },
    "Divisor":{
        "prefix": "Divisor",
        "body": [
            "vector<long long> Divisor(long long n) {",
            "    vector<long long> res;",
            "    for (int i = 1; (long long)i * i <= n; i++) {",
            "        if (n % i == 0) {",
            "            res.push_back(i);",
            "            if (i != n / i) res.push_back(n / i);",
            "        }",
            "    }",
            "    sort(begin(res), end(res));",
            "    return res;",
            "}"
        ],
        "description": "Divisor"
    },
    "eratos":{
        "prefix": "eratos",
        "body": [
            "vector<bool> eratos(int n) {",
            "    vector<bool> primes(n + 1, true);",
            "    primes[0] = primes[1] = false;",
            "    for (int i = 2; i * i <= n; i++) {",
            "        if (!primes[i]) continue;",
            "        for (int j = i * i; j <= n; j += i) {",
            "            primes[j] = false;",
            "        }",
            "    }",
            "    return primes;",
            "}"
        ],
        "description": "eratos"
    },
    "FFT":{
        "prefix": "FFT",
        "body": [
            "/*",
            "    https://ei1333.github.io/luzhiled/snippets/math/fast-fourier-transform.html",
            "*/",
            "namespace FFT {",
            "using real = double;",
            "struct C {",
            "    real x, y;",
            "",
            "    C() : x(0), y(0) {}",
            "    C(real x, real y) : x(x), y(y) {}",
            "",
            "    inline C operator+(const C &c) const {",
            "        return C(x + c.x, y + c.y);",
            "    }",
            "    inline C operator-(const C &c) const {",
            "        return C(x - c.x, y - c.y);",
            "    }",
            "    inline C operator*(const C &c) const {",
            "        return C(x * c.x - y * c.y, x * c.y + y * c.x);",
            "    }",
            "    inline C conj() const {",
            "        return C(x, -y);",
            "    }",
            "};",
            "",
            "const real PI = acosl(-1);",
            "int base = 1;",
            "vector<C> rts = {{0, 0}, {1, 0}};",
            "vector<int> rev = {0, 1};",
            "",
            "void ensureBase(int nbase) {",
            "    if (nbase <= base) return;",
            "    rev.resize(1 << nbase);",
            "    rts.resize(1 << nbase);",
            "    for (int i = 0; i < (1 << nbase); i++) {",
            "        rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));",
            "    }",
            "    while (base < nbase) {",
            "        real angle = PI * 2.0 / (1 << (base + 1));",
            "        for (int i = 1 << (base - 1); i < (1 << base); i++) {",
            "            rts[i << 1] = rts[i];",
            "            real angle_i = angle * (2 * i + 1 - (1 << base));",
            "            rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));",
            "        }",
            "        base++;",
            "    }",
            "}",
            "",
            "void fft(vector<C> &a, int n) {",
            "    assert((n & (n - 1)) == 0);",
            "    int zeros = __builtin_ctz(n);",
            "    ensureBase(zeros);",
            "    int shift = base - zeros;",
            "    for (int i = 0; i < n; i++) {",
            "        if (i < (rev[i] >> shift)) {",
            "            swap(a[i], a[rev[i] >> shift]);",
            "        }",
            "    }",
            "    for (int k = 1; k < n; k <<= 1) {",
            "        for (int i = 0; i < n; i += 2 * k) {",
            "            for (int j = 0; j < k; j++) {",
            "                C z = a[i + j + k] * rts[j + k];",
            "                a[i + j + k] = a[i + j] - z;",
            "                a[i + j] = a[i + j] + z;",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "vector<long long> multiply(const vector<int> &a, const vector<int> &b) {",
            "    int need = a.size() + b.size() - 1;",
            "    int nbase = 1;",
            "    while ((1 << nbase) < need) nbase++;",
            "    ensureBase(nbase);",
            "    int sz = 1 << nbase;",
            "    vector<C> fa(sz);",
            "    for (int i = 0; i < sz; i++) {",
            "        int x = (i < a.size() ? a[i] : 0);",
            "        int y = (i < b.size() ? b[i] : 0);",
            "        fa[i] = C(x, y);",
            "    }",
            "    fft(fa, sz);",
            "    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);",
            "    for (int i = 0; i <= (sz >> 1); i++) {",
            "        int j = (sz - i) & (sz - 1);",
            "        C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;",
            "        fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;",
            "        fa[i] = z;",
            "    }",
            "    for (int i = 0; i < (sz >> 1); i++) {",
            "        C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;",
            "        C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];",
            "        fa[i] = A0 + A1 * s;",
            "    }",
            "    fft(fa, sz >> 1);",
            "    vector<long long> res(need);",
            "    for (int i = 0; i < need; i++) {",
            "        res[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);",
            "    }",
            "    return res;",
            "}",
            "}  // namespace FFT"
        ],
        "description": "FFT"
    },
    "isPrime":{
        "prefix": "isPrime",
        "body": [
            "bool isPrime(long long n) {",
            "    for (long long i = 2; i * i <= n; i++) {",
            "        if (n % i == 0) return false;",
            "    }",
            "    return n != 1;",
            "}"
        ],
        "description": "isPrime"
    },
    "Matrix":{
        "prefix": "Matrix",
        "body": [
            "/*",
            "    計算量...",
            "    和, 差 : O(N ^ 2)",
            "    積 : O(N ^ 3)",
            "    行列累乗(N ^ K) : O(N ^ 3 log K)",
            "*/",
            "template <typename T>",
            "struct Matrix {",
            "    typedef vector<vector<T>> mat;",
            "",
            "    mat A;",
            "",
            "    Matrix() {}",
            "    Matrix(int h, int w, T x = T(0)) : A(h, vector<T>(w, x)) {}",
            "    Matrix(mat A) : A(A) {}",
            "",
            "    int size() const {",
            "        return A.size();",
            "    }",
            "    const vector<T>& operator[](int i) const {",
            "        return A[i];",
            "    }",
            "    vector<T>& operator[](int i) {",
            "        return A[i];",
            "    }",
            "",
            "    Matrix& operator+=(const Matrix& B) {",
            "        assert(A.size() == B.size());",
            "        assert(A[0].size() == B[0].size());",
            "        for (int i = 0; i < A.size(); i++) {",
            "            for (int j = 0; j < A[0].size(); j++) {",
            "                A[i][j] += B[i][j];",
            "            }",
            "        }",
            "        return *this;",
            "    }",
            "",
            "    Matrix& operator-=(const Matrix& B) {",
            "        assert((int)A.size() == (int)B.size());",
            "        assert(A[0].size() == B[0].size());",
            "        for (int i = 0; i < (int)A.size(); i++) {",
            "            for (int j = 0; j < (int)A[0].size(); j++) {",
            "                A[i][j] -= B[i][j];",
            "            }",
            "        }",
            "        return *this;",
            "    }",
            "",
            "    Matrix& operator*=(const Matrix& B) {",
            "        assert((int)A[0].size() == (int)B.size());",
            "        int h = A.size(), w = B[0].size();",
            "        Matrix C(h, w);",
            "        for (int i = 0; i < h; i++) {",
            "            for (int j = 0; j < w; j++) {",
            "                for (int k = 0; k < (int)B.size(); k++) {",
            "                    C[i][j] += A[i][k] * B[k][j];",
            "                }",
            "            }",
            "        }",
            "        this->A = C.A;",
            "        return *this;",
            "    }",
            "",
            "    Matrix operator+(const Matrix& B) const {",
            "        return (Matrix(*this) += B);",
            "    }",
            "    Matrix operator-(const Matrix& B) const {",
            "        return (Matrix(*this) -= B);",
            "    }",
            "    Matrix operator*(const Matrix& B) const {",
            "        return (Matrix(*this) *= B);",
            "    }",
            "",
            "    Matrix identity(int n) {",
            "        Matrix E(n, n);",
            "        for (int i = 0; i < n; i++) E[i][i] = T(1);",
            "        return E;",
            "    }",
            "",
            "    Matrix pow(long long n) {",
            "        Matrix B(A), C = identity(A.size());",
            "        while (n > 0) {",
            "            if (n & 1) C *= B;",
            "            B *= B;",
            "            n >>= 1;",
            "        }",
            "        return C;",
            "    }",
            "};"
        ],
        "description": "Matrix"
    },
    "MODint":{
        "prefix": "MODint",
        "body": [
            "/*",
            "    実行時MODint :",
            "    template <int& MOD = 1000000007>",
            "    static int MOD;",
            "    cin >> MOD;",
            "*/",
            "template <int MOD = 1000000007>",
            "struct Mint {",
            "    int x;",
            "",
            "    constexpr Mint() : x(0) {}",
            "    constexpr Mint(long long t)",
            "        : x(t >= 0 ? (t % MOD) : (MOD - (-t) % MOD) % MOD) {}",
            "",
            "    Mint pow(int n) {",
            "        Mint res(1), t(x);",
            "        while (n > 0) {",
            "            if (n & 1) res *= t;",
            "            t *= t;",
            "            n >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "",
            "    Mint inv() const {",
            "        int a = x, b = MOD, u = 1, v = 0, t;",
            "        while (b > 0) {",
            "            t = a / b;",
            "            a -= t * b;",
            "            swap(a, b);",
            "            u -= t * v;",
            "            swap(u, v);",
            "        }",
            "        return Mint(u);",
            "    }",
            "",
            "    Mint &operator+=(Mint a) {",
            "        x += a.x;",
            "        if (x >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "",
            "    Mint &operator-=(Mint a) {",
            "        x += MOD - a.x;",
            "        if (x >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "",
            "    Mint &operator*=(Mint a) {",
            "        x = int(1LL * x * a.x % MOD);",
            "        return *this;",
            "    }",
            "",
            "    Mint &operator/=(Mint a) {",
            "        return (*this) *= a.inv();",
            "    }",
            "",
            "    Mint operator+(Mint a) const {",
            "        return Mint(x) += a;",
            "    }",
            "    Mint operator-(Mint a) const {",
            "        return Mint(x) -= a;",
            "    }",
            "    Mint operator*(Mint a) const {",
            "        return Mint(x) *= a;",
            "    }",
            "    Mint operator/(Mint a) const {",
            "        return Mint(x) /= a;",
            "    }",
            "",
            "    Mint operator-() const {",
            "        return Mint(-x);",
            "    }",
            "",
            "    bool operator==(const Mint a) {",
            "        return x == a.x;",
            "    }",
            "    bool operator!=(const Mint a) {",
            "        return x != a.x;",
            "    }",
            "    bool operator<(const Mint a) {",
            "        return x < a.x;",
            "    }",
            "",
            "    friend ostream &operator<<(ostream &os, const Mint &a) {",
            "        return os << a.x;",
            "    }",
            "",
            "    friend istream &operator>>(istream &is, Mint &a) {",
            "        int t;",
            "        is >> t;",
            "        a = Mint<MOD>(t);",
            "        return (is);",
            "    }",
            "};"
        ],
        "description": "MODint"
    },
    "MODpow":{
        "prefix": "MODpow",
        "body": [
            "template <typename T>",
            "T MODpow(T x, T n, T MOD = 1000000007) {",
            "    T res = 1;",
            "    while (n > 0) {",
            "        if (n & 1) res = res * x % MOD;",
            "        x = x * x % MOD;",
            "        n >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "MODpow"
    },
    "osa_k":{
        "prefix": "osa_k",
        "body": [
            "struct osa_k {",
            "    vector<int> minfactor;",
            "",
            "    osa_k(int n) {",
            "        eratos(n);",
            "    }",
            "",
            "    vector<int> eratos(int n) {",
            "        minfactor.resize(n + 1);",
            "        iota(minfactor.begin(), minfactor.end(), 0);",
            "        for (int i = 2; i * i <= n; i++) {",
            "            if (minfactor[i] < i) continue;",
            "            for (int j = i * i; j <= n; j += i) {",
            "                if (minfactor[j] == j) minfactor[j] = i;",
            "            }",
            "        }",
            "        return minfactor;",
            "    }",
            "",
            "    map<int, int> PrimeFactor(int n) {",
            "        map<int, int> mp;",
            "        while (n > 1) {",
            "            mp[minfactor[n]]++;",
            "            n /= minfactor[n];",
            "        }",
            "        return mp;",
            "    }",
            "};"
        ],
        "description": "osa_k"
    },
    "PascalTriangle":{
        "prefix": "PascalTriangle",
        "body": [
            "template <typename T>",
            "vector<vector<T>> PascalTriangle(int n) {",
            "    vector<vector<T>> C(n + 1, vector<T>(n + 1));",
            "    for (int i = 0; i <= n; i++) {",
            "        for (int j = 0; j <= i; j++) {",
            "            if (j == 0 || j == i)",
            "                C[i][j] = 1;",
            "            else",
            "                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];",
            "        }",
            "    }",
            "    return C;",
            "}"
        ],
        "description": "PascalTriangle"
    },
    "pow":{
        "prefix": "pow",
        "body": [
            "template <typename T>",
            "T pow(T x, T n) {",
            "    T res = 1;",
            "    while (n > 0) {",
            "        if (n & 1) res = res * x;",
            "        x = x * x;",
            "        n >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "pow"
    },
    "PrimeFactor":{
        "prefix": "PrimeFactor",
        "body": [
            "map<long long, int> PrimeFactor(long long n) {",
            "    map<long long, int> mp;",
            "    for (int i = 2; (long long)i * i <= n; i++) {",
            "        while (n % i == 0) {",
            "            mp[i]++;",
            "            n /= i;",
            "        }",
            "    }",
            "    if (n != 1) mp[n]++;",
            "    return mp;",
            "}"
        ],
        "description": "PrimeFactor"
    },
    "SOD":{
        "prefix": "SOD",
        "body": [
            "long long SOD(long long n) {",
            "    long long sum = 0;",
            "    while (n > 0) {",
            "        sum += n % 10;",
            "        n /= 10;",
            "    }",
            "    return sum;",
            "}"
        ],
        "description": "SOD"
    },
    "compress":{
        "prefix": "compress",
        "body": [
            "template <typename T>",
            "vector<T> compress(vector<T> vec) {",
            "    sort(vec.begin(), vec.end());",
            "    vec.erase(unique(vec.begin(), vec.end()), vec.end());",
            "    return vec;",
            "}",
            "",
            "template <typename T>",
            "map<T, int> dict(vector<T>& vec) {",
            "    map<T, int> res;",
            "    for (int i = 0; i < (int)vec.size(); i++) {",
            "        res[vec[i]] = i;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "compress"
    },
    "direction4":{
        "prefix": "direction4",
        "body": [
            "int dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0};"
        ],
        "description": "direction4"
    },
    "direction8":{
        "prefix": "direction8",
        "body": [
            "int dy[] = {0, 1, 1, 1, 0, -1, -1, -1}, dx[] = {1, 1, 0, -1, -1, -1, 0, 1};"
        ],
        "description": "direction8"
    },
    "Doubling":{
        "prefix": "Doubling",
        "body": [
            "struct Doubling {",
            "    const int n, LOG;",
            "    vector<vector<int>> nxt;",
            "",
            "    Doubling(int n, int LOG = 60) : n(n), LOG(LOG) {",
            "        nxt.resize(LOG + 1, vector<int>(n, -1));",
            "    }",
            "",
            "    void set_next(int idx, int x) {",
            "        nxt[0][idx] = x;",
            "    }",
            "",
            "    void build() {",
            "        for (int i = 0; i < LOG; i++) {",
            "            for (int j = 0; j < n; j++) {",
            "                if (nxt[i][j] == -1)",
            "                    nxt[i + 1][j] = -1;",
            "                else",
            "                    nxt[i + 1][j] = nxt[i][nxt[i][j]];",
            "            }",
            "        }",
            "    }",
            "",
            "    int query(int cur, long long dist) {",
            "        for (int i = LOG; i >= 0; i--) {",
            "            if (cur < 0) return -1;",
            "            if (dist & (1LL << i)) cur = nxt[i][cur];",
            "        }",
            "        return cur;",
            "    }",
            "};"
        ],
        "description": "Doubling"
    },
    "RunLengthEncoding":{
        "prefix": "RunLengthEncoding",
        "body": [
            "template <typename T>",
            "vector<pair<int, T>> RLE(vector<T> v) {",
            "    int n = v.size();",
            "    vector<pair<int, T>> res;",
            "    T pre = v[0];",
            "    int cnt = 1;",
            "    for (int i = 1; i < n; i++) {",
            "        if (v[i] != pre) {",
            "            res.emplace_back(cnt, pre);",
            "            pre = v[i];",
            "            cnt = 0;",
            "        }",
            "        cnt++;",
            "    }",
            "    res.emplace_back(cnt, pre);",
            "    return res;",
            "}"
        ],
        "description": "RunLengthEncoding"
    },
    "RollingHash":{
        "prefix": "RollingHash",
        "body": [
            "template <typename T>",
            "struct RollingHash {",
            "    using ll = long long;",
            "    ll B_1, B_2, MOD_1, MOD_2;",
            "    vector<ll> hash_1, hash_2, pow_1, pow_2;",
            "",
            "    RollingHash(vector<T> v, ll B_1 = 1007, ll B_2 = 1009,",
            "                ll MOD_1 = 1000000007, ll MOD_2 = 1000000009)",
            "        : B_1(B_1), B_2(B_2), MOD_1(MOD_1), MOD_2(MOD_2) {",
            "        init(v);",
            "    }",
            "",
            "    RollingHash(string& s, ll B_1 = 1007, ll B_2 = 1009, ll MOD_1 = 1000000007,",
            "                ll MOD_2 = 1000000009)",
            "        : B_1(B_1), B_2(B_2), MOD_1(MOD_1), MOD_2(MOD_2) {",
            "        vector<T> v;",
            "        for (char c : s) v.emplace_back(c);",
            "        init(v);",
            "    }",
            "",
            "    void init(vector<T> v) {",
            "        int n = v.size();",
            "        hash_1.assign(n + 1, 0);",
            "        hash_2.assign(n + 1, 0);",
            "        pow_1.assign(n + 1, 1);",
            "        pow_2.assign(n + 1, 1);",
            "        for (int i = 0; i < n; i++) {",
            "            hash_1[i + 1] = (hash_1[i] * B_1 + v[i]) % MOD_1;",
            "            hash_2[i + 1] = (hash_2[i] * B_2 + v[i]) % MOD_2;",
            "            pow_1[i + 1] = pow_1[i] * B_1 % MOD_1;",
            "            pow_2[i + 1] = pow_2[i] * B_2 % MOD_2;",
            "        }",
            "    }",
            "",
            "    pair<ll, ll> get(int l, int r) {",
            "        ll res_1 =",
            "            ((hash_1[r] - hash_1[l] * pow_1[r - l]) % MOD_1 + MOD_1) % MOD_1;",
            "        ll res_2 =",
            "            ((hash_2[r] - hash_2[l] * pow_2[r - l]) % MOD_2 + MOD_2) % MOD_2;",
            "        return pair<ll, ll>(res_1, res_2);",
            "    }",
            "};"
        ],
        "description": "RollingHash"
    },
    "Zalgorithm":{
        "prefix": "Zalgorithm",
        "body": [
            "template <typename T>",
            "vector<int> Zalgorithm(const vector<T>& v) {",
            "    int n = v.size();",
            "    vector<int> res(n);",
            "    res[0] = n;",
            "    int i = 1, j = 0;",
            "    while (i < n) {",
            "        while (i + j < n && v[j] == v[i + j]) j++;",
            "        res[i] = j;",
            "        if (j == 0) {",
            "            i++;",
            "            continue;",
            "        }",
            "        int k = 1;",
            "        while (i + k < n && k + res[k] < j) {",
            "            res[i + k] = res[k];",
            "            k++;",
            "        }",
            "        i += k;",
            "        j -= k;",
            "    }",
            "    return res;",
            "}",
            "",
            "vector<int> Zalgorithm(const string& s) {",
            "    return Zalgorithm(vector<char>(s.begin(), s.end()));",
            "}"
        ],
        "description": "Zalgorithm"
    },
    "atcoder":{
        "prefix": "atcoder",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <atcoder/all>",
            "using namespace std;",
            "using namespace atcoder;",
            "#define rep(i, n) for (int i = 0; i < (int)(n); i++)",
            "#define ALL(v) (v).begin(), (v).end()",
            "using ll = long long;",
            "constexpr int INF = 1e9;",
            "constexpr long long LINF = 1e18;",
            "constexpr long long MOD = 1e9 + 7;",
            "",
            "signed main() {",
            "",
            "    return 0;",
            "}"
        ],
        "description": "atcoder"
    },
    "chmax":{
        "prefix": "chmax",
        "body": [
            "template <typename T1, typename T2>",
            "inline void chmax(T1 &a, T2 b) {",
            "    if (a < b) a = b;",
            "}"
        ],
        "description": "chmax"
    },
    "chmin":{
        "prefix": "chmin",
        "body": [
            "template <typename T1, typename T2>",
            "inline void chmin(T1 &a, T2 b) {",
            "    if (a > b) a = b;",
            "}"
        ],
        "description": "chmin"
    },
    "co":{
        "prefix": "co",
        "body": [
            "cout << $1 << endl;"
        ],
        "description": "co"
    },
    "fastIO":{
        "prefix": "fastIO",
        "body": [
            "cin.tie(0);",
            "ios::sync_with_stdio(0);"
        ],
        "description": "fastIO"
    },
    "main":{
        "prefix": "main",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define rep(i, n) for (int i = 0; i < (int)(n); i++)",
            "#define ALL(v) (v).begin(), (v).end()",
            "using ll = long long;",
            "constexpr int INF = 1e9;",
            "constexpr long long LINF = 1e18;",
            "constexpr long long MOD = 1e9 + 7;",
            "",
            "signed main() {",
            "    ",
            "    return 0;",
            "}"
        ],
        "description": "main"
    },
    "popcount":{
        "prefix": "popcount",
        "body": [
            "__builtin_popcount($1)"
        ],
        "description": "popcount"
    },
    "QCFium":{
        "prefix": "QCFium",
        "body": [
            "#pragma GCC target(\"avx2\")",
            "#pragma GCC optimize(\"O3\")",
            "#pragma GCC optimize(\"unroll-loops\")"
        ],
        "description": "QCFium"
    },
    "rep":{
        "prefix": "rep",
        "body": [
            "rep($1, $2) {",
            "    $3",
            "}"
        ],
        "description": "rep"
    },
    "testcases":{
        "prefix": "testcases",
        "body": [
            "int number_of_testcases;",
            "cin >> number_of_testcases;",
            "while (number_of_testcases--) {",
            "    $1",
            "}"
        ],
        "description": "testcases"
    },
    "HLD":{
        "prefix": "HLD",
        "body": [
            "// https://beet-aizu.github.io/library/tree/heavylightdecomposition.cpp",
            "class HLD {",
            "   private:",
            "    void dfs_sz(int v) {",
            "        auto &es = G[v];",
            "        if (~par[v]) es.erase(find(es.begin(), es.end(), par[v]));",
            "",
            "        for (int &u : es) {",
            "            par[u] = v;",
            "            dfs_sz(u);",
            "            sub[v] += sub[u];",
            "            if (sub[u] > sub[es[0]]) swap(u, es[0]);",
            "        }",
            "    }",
            "",
            "    void dfs_hld(int v, int &pos) {",
            "        vid[v] = pos++;",
            "        inv[vid[v]] = v;",
            "        for (int u : G[v]) {",
            "            if (u == par[v]) continue;",
            "            nxt[u] = (u == G[v][0] ? nxt[v] : u);",
            "            dfs_hld(u, pos);",
            "        }",
            "    }",
            "",
            "   public:",
            "    vector<vector<int> > G;",
            "",
            "    // vid: vertex -> idx",
            "    // inv: idx -> vertex",
            "    vector<int> vid, nxt, sub, par, inv;",
            "",
            "    HLD(int n) : G(n), vid(n, -1), nxt(n), sub(n, 1), par(n, -1), inv(n) {}",
            "",
            "    void add_edge(int u, int v) {",
            "        G[u].emplace_back(v);",
            "        G[v].emplace_back(u);",
            "    }",
            "",
            "    void build(int r = 0) {",
            "        int pos = 0;",
            "        dfs_sz(r);",
            "        nxt[r] = r;",
            "        dfs_hld(r, pos);",
            "    }",
            "",
            "    int lca(int u, int v) {",
            "        while (1) {",
            "            if (vid[u] > vid[v]) swap(u, v);",
            "            if (nxt[u] == nxt[v]) return u;",
            "            v = par[nxt[v]];",
            "        }",
            "    }",
            "",
            "    template <typename F>",
            "    void for_each(int u, int v, const F &f) {",
            "        while (1) {",
            "            if (vid[u] > vid[v]) swap(u, v);",
            "            f(max(vid[nxt[v]], vid[u]), vid[v] + 1);",
            "            if (nxt[u] != nxt[v])",
            "                v = par[nxt[v]];",
            "            else",
            "                break;",
            "        }",
            "    }",
            "",
            "    template <typename F>",
            "    void for_each_edge(int u, int v, const F &f) {",
            "        while (1) {",
            "            if (vid[u] > vid[v]) swap(u, v);",
            "            if (nxt[u] != nxt[v]) {",
            "                f(vid[nxt[v]], vid[v] + 1);",
            "                v = par[nxt[v]];",
            "            } else {",
            "                if (u != v) f(vid[u] + 1, vid[v] + 1);",
            "                break;",
            "            }",
            "        }",
            "    }",
            "};"
        ],
        "description": "HLD"
    },
    "LowestCommonAncestor":{
        "prefix": "LowestCommonAncestor",
        "body": [
            "struct LCA {",
            "    int n, h;",
            "    vector<vector<int>> G, par;",
            "    vector<int> depth;",
            "",
            "    LCA(int n) : n(n), G(n), depth(n) {",
            "        h = 1;",
            "        while ((1 << h) <= n) h++;",
            "        par.assign(h, vector<int>(n, -1));",
            "    }",
            "",
            "    void add_edge(int u, int v) {",
            "        G[u].emplace_back(v);",
            "        G[v].emplace_back(u);",
            "    }",
            "",
            "    void dfs(int v, int p, int d) {",
            "        par[0][v] = p;",
            "        depth[v] = d;",
            "        for (int u : G[v]) {",
            "            if (u != p) dfs(u, v, d + 1);",
            "        }",
            "    }",
            "",
            "    void build(int r = 0) {",
            "        dfs(r, -1, 0);",
            "        for (int k = 0; k + 1 < h; k++) {",
            "            for (int v = 0; v < n; v++) {",
            "                if (par[k][v] != -1) par[k + 1][v] = par[k][par[k][v]];",
            "            }",
            "        }",
            "    }",
            "",
            "    int query(int u, int v) {",
            "        if (depth[u] > depth[v]) swap(u, v);",
            "        for (int k = 0; k < h; k++) {",
            "            if ((depth[v] - depth[u]) >> k & 1) v = par[k][v];",
            "        }",
            "        if (u == v) return u;",
            "        for (int k = h - 1; k >= 0; k--) {",
            "            if (par[k][u] != par[k][v]) {",
            "                u = par[k][u];",
            "                v = par[k][v];",
            "            }",
            "        }",
            "        return par[0][u];",
            "    }",
            "",
            "    int dist(int u, int v) {",
            "        return depth[u] + depth[v] - depth[query(u, v)] * 2;",
            "    }",
            "};"
        ],
        "description": "LowestCommonAncestor"
    },
    "ReRooting":{
        "prefix": "ReRooting",
        "body": [
            "template <typename T, typename ET>",
            "struct ReRooting {",
            "    struct edge {",
            "        int to;",
            "        ET data;",
            "        edge(int to, ET data) : to(to), data(data) {}",
            "    };",
            "",
            "    using F = function<T(T, T)>;",
            "    using L = function<T(T, ET)>;",
            "    vector<vector<edge>> G;",
            "    vector<T> dp, res;",
            "    const T id;",
            "    const F f;",
            "    const L l;",
            "",
            "    ReRooting(int V, const F f, const L l, const T id)",
            "        : G(V), f(f), l(l), id(id), dp(V, id), res(V, id) {}",
            "",
            "    void add_edge(int u, int v, ET c, ET cr) {",
            "        G[u].emplace_back(v, c);",
            "        G[v].emplace_back(u, cr);",
            "    }",
            "",
            "    void add_edge(int u, int v, ET c) {",
            "        add_edge(u, v, c, c);",
            "    }",
            "",
            "    void dfs(int v, int pre) {",
            "        for (auto e : G[v]) {",
            "            if (e.to == pre) continue;",
            "            dfs(e.to, v);",
            "            dp[v] = f(dp[v], l(dp[e.to], e.data));",
            "        }",
            "    }",
            "",
            "    void rdfs(int v, int pre) {",
            "        for (auto e : G[v]) {",
            "            res[v] = f(res[v], l(dp[e.to], e.data));",
            "        }",
            "        int n = G[v].size();",
            "        vector<T> lsum(n + 1, id), rsum(n + 1, id);",
            "        for (int i = 0; i < n; i++) {",
            "            lsum[i + 1] = f(lsum[i], l(dp[G[v][i].to], G[v][i].data));",
            "        }",
            "        for (int i = n - 1; i >= 0; i--) {",
            "            rsum[i] = f(rsum[i + 1], l(dp[G[v][i].to], G[v][i].data));",
            "        }",
            "        for (int i = 0; i < n; i++) {",
            "            if (G[v][i].to == pre) continue;",
            "            dp[v] = f(lsum[i], rsum[i + 1]);",
            "            rdfs(G[v][i].to, v);",
            "        }",
            "    }",
            "",
            "    vector<T> solve() {",
            "        dfs(0, -1);",
            "        rdfs(0, -1);",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "ReRooting"
    }
}