{
    "LazySegmentTree":{
        "prefix": "LazySegmentTree",
        "body": [
            "/*",
            "    LazySegmentTree<int, int> seg(f, g, h, p, def, laz_def) のように宣言する",
            "    RMQ and RUQ の場合 : ",
            "    auto f = [](int a, int b){return min(a, b);};",
            "    auto g = [](int a, int b){return b;};",
            "    auto h = [](int a, int b){returm b;};",
            "    auto p = [](int a, int b){return a;};",
            "    RSQ and RAQ の場合 : ",
            "    auto f = [](ll a, ll b){return a + b;};",
            "    auto g = [](ll a, ll b){return a + b;};",
            "    auto h = [](ll a, ll b){returm a + b;};",
            "    auto p = [](ll a, int b){return a * b;};",
            "*/",
            "template <typename Monoid, typename OperatorMonoid>",
            "struct LazySegmentTree{",
            "    using F = function<Monoid(Monoid, Monoid)>;",
            "    using G = function<Monoid(Monoid, OperatorMonoid)>;",
            "    using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;",
            "    using P = function<OperatorMonoid(OperatorMonoid, int)>;",
            "    int n;",
            "    vector<Monoid> dat;",
            "    vector<OperatorMonoid> laz;",
            "    F f;",
            "    G g;",
            "    H h;",
            "    P p;",
            "    Monoid def;",
            "    OperatorMonoid laz_def;",
            "",
            "    LazySegmentTree(F f, G g, H h, P p, Monoid def, OperatorMonoid laz_def) : f(f), g(g), h(h), p(p), def(def), laz_def(laz_def){}",
            "",
            "    void build(const vector<Monoid> & vec){",
            "        int siz = vec.size();",
            "        n = 1;",
            "        while(n < siz) n *= 2;",
            "        dat.assign(2 * n - 1, def);",
            "        laz.assign(2 * n - 1, laz_def);",
            "        for(int i = 0; i < siz; i++) dat[n - 1 + i] = vec[i];",
            "        for(int i = n - 2; i >= 0; i--) dat[i] = f(dat[2 * i + 1], dat[2 * i + 2]);",
            "    }",
            "",
            "    void update(int a, int b, OperatorMonoid x){",
            "        update(a, b, x, 0, 0, n);",
            "    }",
            "",
            "    Monoid query(int a, int b){",
            "        return query(a, b, 0, 0, n);",
            "    }",
            "",
            "private:",
            "    void eval(int k, int l, int r){",
            "        if(laz[k] != laz_def){",
            "            dat[k] = g(dat[k], p(laz[k], r - l));",
            "            if(r - l > 1){",
            "                laz[2 * k + 1] = h(laz[2 * k + 1], laz[k]);",
            "                laz[2 * k + 2] = h(laz[2 * k + 2], laz[k]);",
            "            }",
            "            laz[k] = laz_def;",
            "        }",
            "    }",
            "",
            "    void update(int a, int b, OperatorMonoid x, int k, int l, int r){",
            "        eval(k, l, r);",
            "        if(r <= a || b <= l) return;",
            "        if(a <= l && r <= b){",
            "            laz[k] = h(laz[k], x);",
            "            eval(k, l, r);",
            "        }else{",
            "            update(a, b, x, 2 * k + 1, l, (l + r) / 2);",
            "            update(a, b, x, 2 * k + 2, (l + r) / 2, r);",
            "            dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);",
            "        }",
            "    }",
            "",
            "    Monoid query(int a, int b, int k, int l, int r){",
            "        if(r <= a || b <= l) return def;",
            "        eval(k, l, r);",
            "        if(a <= l && r <= b) return dat[k];",
            "        Monoid vl = query(a, b, 2 * k + 1, l, (l + r) / 2);",
            "        Monoid vr = query(a, b, 2 * k + 2, (l + r) / 2, r);",
            "        return f(vl, vr);",
            "    }",
            "};"
        ],
        "description": "LazySegmentTree"
    },
    "SegmentTree":{
        "prefix": "SegmentTree",
        "body": [
            "/*",
            "    SegmentTree<int> seg(f, def) のように宣言する",
            "    RMQ の場合 : ",
            "    auto f = [](int a, int b){return min(a, b);};",
            "    int def = INF;",
            "*/",
            "template <typename Monoid>",
            "struct SegmentTree{",
            "    using F = function<Monoid(Monoid, Monoid)>;",
            "    int n;",
            "    vector<Monoid> dat;",
            "    F f;",
            "    Monoid def; //初期値かつ単位元",
            "",
            "    SegmentTree(F f, Monoid def) : f(f), def(def) {}",
            "",
            "    void build(const vector<Monoid> & vec){ //元配列vecをセグメントツリーで表現する",
            "        int siz = vec.size();",
            "        n = 1;",
            "        while(n < siz) n *= 2;",
            "        dat.assign(2 * n - 1, def);",
            "        for(int i = 0; i < siz; i++) dat[n - 1 + i] = vec[i]; //最下段に値をいれる",
            "        for(int i = n - 2; i >= 0; i--) dat[i] = f(dat[2 * i + 1], dat[2 * i + 2]); //下の段から順番に値をいれる",
            "    }",
            "",
            "    void update(int k, Monoid x){",
            "        k += (n - 1); //最下段のノードにアクセスする",
            "        dat[k] = x; //最下段のノードを更新したら、下の段から順番に値をいれる",
            "        while(k > 0){",
            "            k = (k - 1) / 2;",
            "            dat[k] = f(dat[2 * k + 1], dat[2 * k + 2]);",
            "        }",
            "    }",
            "",
            "    //[a, b)の区間クエリを実行",
            "    Monoid query(int a, int b){",
            "        return query(a, b, 0, 0, n);",
            "    }",
            "",
            "private:",
            "    Monoid query(int a, int b, int k, int l, int r){",
            "        if(r <= a || b <= l) return def; //要求区間と対象区間が交わらなければ、def",
            "        if(a <= l && r <= b) return dat[k]; //要求区間が対象区間を完全に含んでいれば、対象区間を答えの計算に使う",
            "        //要求区間が対象区間の一部を含んでいれば、",
            "        Monoid vl = query(a, b, 2 * k + 1, l, (l + r) / 2);",
            "        Monoid vr = query(a, b, 2 * k + 2, (l + r) / 2, r);",
            "        return f(vl, vr);",
            "    }",
            "};"
        ],
        "description": "SegmentTree"
    },
    "UnionFind":{
        "prefix": "UnionFind",
        "body": [
            "struct UnionFind{",
            "    vector<int> par;",
            "    vector<int> siz;",
            "",
            "    UnionFind(int n){",
            "        init(n);",
            "    }",
            "    ",
            "    void init(int n){",
            "        par.resize(n);",
            "        siz.resize(n);",
            "        for(int i = 0; i < n; i++){",
            "            par[i] = i;",
            "            siz[i] = 1;",
            "        }",
            "    }",
            "",
            "    int root(int x){",
            "        if(par[x] == x) return x;",
            "        else return par[x] = root(par[x]);",
            "    }",
            "",
            "    void unite(int x, int y){",
            "        x = root(x);",
            "        y = root(y);",
            "        if(x == y) return;",
            "        if(siz[x] < siz[y]) swap(x, y);",
            "        siz[x] += siz[y];",
            "        par[y] = x;",
            "    }",
            "",
            "    bool same(int x, int y){",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    int size(int x){",
            "        return siz[root(x)];",
            "    }",
            "};"
        ],
        "description": "UnionFind"
    },
    "RectangleSum":{
        "prefix": "RectangleSum",
        "body": [
            "template <typename T>",
            "struct RectangleSum{",
            "    vector<vector<T>> sum;",
            "",
            "    RectangleSum(int h, int w){",
            "        init(h, w);",
            "    }",
            "",
            "    void init(int h, int w){",
            "        sum.resize(h + 1, vector<T> (w + 1, 0));",
            "    }",
            "",
            "    void add(int y, int x, T val){",
            "        y++;",
            "        x++;",
            "        sum[y][x] += val;",
            "    }",
            "",
            "    void build(){",
            "        for(int i = 1; i < sum.size(); i++){",
            "            for(int j = 1; j < sum[i].size(); j++){",
            "                sum[i][j] += sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];",
            "            }",
            "        }",
            "    }",
            "",
            "    T getsum(int top, int left, int bottom, int right){//[top, bottom], [left, right]",
            "        return sum[bottom + 1][right + 1] - sum[bottom + 1][left] - sum[top][right + 1] + sum[top][left];",
            "    }",
            "};"
        ],
        "description": "RectangleSum"
    },
    "geometry":{
        "prefix": "geometry",
        "body": [
            "#define EPS (1e-10)",
            "#define equals(a, b) (fabs((a) - (b)) < EPS)",
            "",
            "struct Point {",
            "    double x, y;",
            "",
            "    Point(double x = 0, double y = 0) : x(x), y(y) {}",
            "    ",
            "    Point operator + (Point p) { return Point(x + p.x, y + p.y); }",
            "    Point operator - (Point p) { return Point(x - p.x, y - p.y); }",
            "    Point operator * (double a) { return Point(a * x, a * y); }",
            "    Point operator / (double a) { return Point(x / a, y / a); }",
            "",
            "    double abs() { return sqrt(norm()); }",
            "    double norm() { return x * x + y * y; }",
            "",
            "    bool operator < (const Point &p) const {",
            "        return x != p.x ? x < p.x : y < p.y;",
            "    }",
            "",
            "    bool operator == (const Point &p) const {",
            "        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;",
            "    }",
            "};",
            "",
            "typedef Point Vector;",
            "",
            "double norm(Vector a) { return a.x * a.x + a.y * a.y; }",
            "double abs(Vector a) { return sqrt(norm(a)); }",
            "double dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }",
            "double cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }",
            "",
            "struct Segment {",
            "    Point p1, p2;",
            "    Segment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}",
            "};",
            "",
            "typedef Segment Line;",
            "",
            "struct Circle {",
            "    Point c;",
            "    double r;",
            "    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}",
            "};",
            "",
            "typedef vector<Point> Polygon;",
            "",
            "//直交判定",
            "bool isOrthogonal(Vector a, Vector b) {",
            "    return equals(dot(a, b), 0.0);",
            "}",
            "",
            "bool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {",
            "    return isOrthogonal(a1 - a2, b1 - b2);",
            "}",
            "",
            "bool isOrthogonal(Segment s1, Segment s2) {",
            "    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);",
            "}",
            "",
            "//平行判定",
            "bool isParallel(Vector a, Vector b) {",
            "    return equals(cross(a, b), 0.0);",
            "}",
            "",
            "bool isParallel(Point a1, Point a2, Point b1, Point b2) {",
            "    return isParallel(a1 - a2, b1 - b2);",
            "}",
            "",
            "bool isParallel(Segment s1, Segment s2) {",
            "    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);",
            "}",
            "",
            "//線分 s に点 p から垂線を引いた交点を求める",
            "Point project(Segment s, Point p) {",
            "    Vector base = s.p2 - s.p1;",
            "    double r = dot(p - s.p1, base) / norm(base);",
            "    return s.p1 + base * r;",
            "}",
            "",
            "//線分 s を対称軸として点 p と線対称の位置にある点を求める",
            "Point reflect(Segment s, Point p) {",
            "    return p + (project(s, p) - p) * 2.0;",
            "}",
            "",
            "double getDistance(Point a, Point b) {",
            "    return abs(a - b);",
            "}",
            "",
            "double getDistanceLP(Line l, Point p) {",
            "    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));",
            "}",
            "",
            "double getDistanceSP(Segment s, Point p) {",
            "    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);",
            "    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);",
            "    return getDistanceLP(s, p);",
            "}",
            "",
            "bool intersect(Segment s1, Segment s2);",
            "",
            "double getDistanceSS(Segment s1, Segment s2) {",
            "    if ( intersect(s1, s2) ) return 0.0;",
            "    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),",
            "               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));",
            "}",
            "",
            "static const int COUNTER_CLOCKWISE = 1;",
            "static const int CLOCKWISE = -1;",
            "static const int ONLINE_BACK = 2;",
            "static const int ONLINE_FRONT = -2;",
            "static const int ON_SEGMENT = 0;",
            "",
            "int ccw(Point p0, Point p1, Point p2) {",
            "    Vector a = p1 - p0;",
            "    Vector b = p2 - p0;",
            "    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;",
            "    if( cross(a, b) < -EPS ) return CLOCKWISE;",
            "    if( dot(a, b) < -EPS ) return ONLINE_BACK;",
            "    if( a.norm() < b.norm() ) return ONLINE_FRONT;",
            "",
            "    return ON_SEGMENT;",
            "}",
            "",
            "//交差判定",
            "bool intersect(Point p1, Point p2, Point p3, Point p4) {",
            "    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&",
            "             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );",
            "}",
            "",
            "bool intersect(Segment s1, Segment s2) {",
            "    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);",
            "}",
            "",
            "Point getCrossPointSS(Segment s1, Segment s2) {",
            "    Vector base = s2.p2 - s2.p1;",
            "    double d1 = abs(cross(base, s1.p1 - s2.p1));",
            "    double d2 = abs(cross(base, s1.p2 - s2.p1));",
            "    double t = d1 / (d1 + d2);",
            "    return s1.p1 + (s1.p2 - s1.p1) * t;",
            "}",
            "",
            "pair<Point, Point> getCrossPointCL(Circle c, Line l) {",
            "    // assert(intersect(c, l));",
            "    Vector pr = project(l, c.c);",
            "    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);",
            "    double base = sqrt(c.r * c.r - norm(pr - c.c));",
            "    return make_pair(pr + e * base, pr - e * base);",
            "}",
            "",
            "double arg(Vector p) { return atan2(p.y, p.x); }",
            "Vector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }",
            "",
            "pair<Point, Point> getCrossPointCC(Circle c1, Circle c2) {",
            "    // assert(intersect(c1, c2));",
            "    double d = abs(c1.c - c2.c);",
            "    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));",
            "    double t = arg(c2.c - c1.c);",
            "    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));",
            "}",
            "",
            "// IN : 2, ON : 1, OUT : 0",
            "int contains(Polygon g, Point p) {",
            "    int n = g.size();",
            "    bool x = false;",
            "    for( int i = 0; i < n; i++ ) {",
            "        Point a = g[i] - p, b = g[(i + 1) % n] - p;",
            "        if ( abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;",
            "        if ( a.y > b.y ) swap(a, b);",
            "        if ( a.y < EPS && EPS < b.y && cross(a, b) > EPS ) x = !x;",
            "    }",
            "    return ( x ? 2 : 0 );",
            "}"
        ],
        "description": "geometry"
    },
    "BellmanFord":{
        "prefix": "BellmanFord",
        "body": [
            "template <typename T>",
            "struct edge{",
            "    int from, to;",
            "    T cost;",
            "    edge(int from, int to, T cost = 1) : from(from), to(to), cost(cost){}",
            "    bool operator < (const edge & e) const{",
            "        return cost < e.cost;",
            "    }",
            "};",
            "",
            "/*",
            "    sからたどりつける負の閉路を検出したとき、空の vector を返す",
            "    頂点数 V, 始点 s, 辺の集合 es, INF として LINF を使うとき : ",
            "    vector<ll> dist = BellmanFord(V, s, es, LINF);",
            "*/",
            "template <typename T>",
            "vector<T> BellmanFord(int V, int s, vector<edge<T>> & es, const T INF = 1e9){",
            "    int E = es.size();",
            "    vector<T> dist(V, INF);",
            "    dist[s] = 0;",
            "    for(int i = 0; i < V - 1; i++){",
            "        for(edge<T> & e : es){",
            "            if(dist[e.from] == INF) continue;",
            "            dist[e.to] = min(dist[e.to], dist[e.from] + e.cost);",
            "        }",
            "    }",
            "    for(edge<T> & e : es){",
            "        if(dist[e.from] == INF) continue;",
            "        if(dist[e.from] + e.cost < dist[e.to]) return vector<T>();",
            "    }",
            "    return dist;",
            "}",
            "",
            "//グラフ全体をみて、負の閉路が存在するとき true を返す",
            "template <typename T>",
            "bool Find_Negative_Loop(int V, vector<edge<T>> & es){",
            "    vector<T> dist(V, 0);",
            "    for(int i = 0; i < V; i++){",
            "        for(edge<T> & e : es){",
            "            if(dist[e.to] > dist[e.from] + e.cost){",
            "                dist[e.to] = dist[e.from] + e.cost;",
            "                if(i == V - 1) return true;",
            "            }",
            "        }",
            "    }",
            "    return false;",
            "}"
        ],
        "description": "BellmanFord"
    },
    "BipartiteMatching":{
        "prefix": "BipartiteMatching",
        "body": [
            "struct BiMatch{",
            "    int V, time;",
            "    vector<vector<int>> G;",
            "    vector<int> match, used;",
            "    vector<bool> dead;",
            "",
            "    BiMatch(int V) : V(V), time(0), G(V), match(V, -1), used(V, -1), dead(V, false){} ",
            "",
            "    void add_edge(int u, int v){",
            "        G[u].emplace_back(v);",
            "        G[v].emplace_back(u);",
            "    }",
            "",
            "    bool dfs(int v){",
            "        used[v] = time;",
            "        for(int u : G[v]){",
            "            if(dead[u]) continue;",
            "            int w = match[u];",
            "            if((w < 0) || (used[w] < time && dfs(w))){",
            "                match[v] = u;",
            "                match[u] = v;",
            "                return true;",
            "            }",
            "        }",
            "        return false;",
            "    }",
            "",
            "    int build(){",
            "        int res = 0;",
            "        for(int v = 0; v < V; v++){",
            "            if(dead[v]) continue;",
            "            if(match[v] < 0){",
            "                time++;",
            "                res += dfs(v);",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "BipartiteMatching"
    },
    "Dijkstra":{
        "prefix": "Dijkstra",
        "body": [
            "template <typename T>",
            "vector<T> Dijkstra(int s, vector<vector<pair<int, T>>> & G, const T INF = 1e9){",
            "    using P = pair<T, int>;",
            "    int V = G.size();",
            "    vector<T> dist(V, INF);",
            "    priority_queue<P, vector<P>, greater<P>> que;",
            "    dist[s] = 0;",
            "    que.emplace(0, s);",
            "    while(!que.empty()){",
            "        P p = que.top();",
            "        que.pop();",
            "        int v = p.second;",
            "        if(dist[v] < p.first) continue;",
            "        for(int i = 0; i < G[v].size(); i++){",
            "            int to = G[v][i].first;",
            "            T cost = G[v][i].second;",
            "            if(dist[to] > dist[v] + cost){",
            "                dist[to] = dist[v] + cost;",
            "                que.emplace(dist[to], to);",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}"
        ],
        "description": "Dijkstra"
    },
    "Kruskal":{
        "prefix": "Kruskal",
        "body": [
            "struct UnionFind{",
            "    vector<int> par;",
            "    vector<int> siz;",
            "",
            "    UnionFind(int n){",
            "        init(n);",
            "    }",
            "    ",
            "    void init(int n){",
            "        par.resize(n);",
            "        siz.resize(n);",
            "        for(int i = 0; i < n; i++){",
            "            par[i] = i;",
            "            siz[i] = 1;",
            "        }",
            "    }",
            "",
            "    int root(int x){",
            "        if(par[x] == x) return x;",
            "        else return par[x] = root(par[x]);",
            "    }",
            "",
            "    void unite(int x, int y){",
            "        x = root(x);",
            "        y = root(y);",
            "        if(x == y) return;",
            "        if(siz[x] < siz[y]) swap(x, y);",
            "        siz[x] += siz[y];",
            "        par[y] = x;",
            "    }",
            "",
            "    bool same(int x, int y){",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    int size(int x){",
            "        return siz[root(x)];",
            "    }",
            "};",
            "",
            "template <typename T>",
            "struct edge{",
            "    int from, to;",
            "    T cost;",
            "    edge(int from, int to, T cost = 1) : from(from), to(to), cost(cost){}",
            "    bool operator < (const edge & e) const{",
            "        return cost < e.cost;",
            "    }",
            "};",
            "",
            "template <typename T>",
            "T Kruskal(int V, vector<edge<T>> & es){",
            "    sort(es.begin(), es.end()); //reverseすると最大全域木",
            "    UnionFind uf(V);",
            "    T res = 0;",
            "    for(edge<T> e : es){",
            "        if(!uf.same(e.from, e.to)){",
            "            uf.unite(e.from, e.to);",
            "            res += e.cost;",
            "        }",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Kruskal"
    },
    "max_flow(Ford-Fulkerson)":{
        "prefix": "max_flow(Ford-Fulkerson)",
        "body": [
            "#define MAX_V 100",
            "",
            "//辺を表す構造体（行き先、容量、逆辺）",
            "struct edge{ int to, cap, rev; };",
            "",
            "vector<edge> G[MAX_V];//グラフの隣接リスト表現",
            "bool used[MAX_V];//DFSですでに調べたかのフラグ",
            "",
            "//fromからtoへ向かう容量capの辺をグラフに追加する",
            "void add_edge(int from, int to, int cap){",
            "    G[from].push_back((edge){to, cap, G[to].size()});",
            "    G[to].push_back((edge){from, 0, G[from].size() - 1});",
            "}",
            "",
            "//増加パスをDFSで探す",
            "int dfs(int v, int t, int f){",
            "    if(v == t) return f;",
            "    used[v] = true;",
            "    for(int i = 0; i < G[v].size(); i++){",
            "        edge &e = G[v][i];",
            "        if(!used[e.to] && e.cap > 0){",
            "            int d = dfs(e.to, t, min(f, e.cap));",
            "            if(d > 0){",
            "                e.cap -= d;",
            "                G[e.to][e.rev].cap += d;",
            "                return d;",
            "            }",
            "        }",
            "    }",
            "    return 0;",
            "}",
            "",
            "//sからtへの最大流を求める",
            "int max_flow(int s, int t){",
            "    int flow = 0;",
            "    for(;;){",
            "        memset(used, 0, sizeof(used));",
            "        int f = dfs(s, t, INF);",
            "        if(f == 0) return flow;",
            "        flow += f;",
            "    }",
            "}"
        ],
        "description": "max_flow(Ford-Fulkerson)"
    },
    "min_cost_flow(bellman_ford)":{
        "prefix": "min_cost_flow(bellman_ford)",
        "body": [
            "#define MAX_V 100",
            "",
            "//辺を表す構造体（行き先、容量、コスト、逆辺）",
            "struct edge{int to, cap, cost, rev; };",
            "",
            "int V;//頂点数",
            "vector<edge> G[MAX_V];//グラフの隣接リスト表現",
            "int dist[MAX_V];//最短距離",
            "int prevv[MAX_V], preve[MAX_V];//直前の頂点と辺",
            "",
            "//fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する",
            "void add_edge(int from, int to, int cap, int cost){",
            "    G[from].push_back((edge){to, cap, cost, G[to].size()});",
            "    G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});",
            "}",
            "",
            "//sからtへの流量fの最小費用流を求める",
            "//流せない場合は-1を返す",
            "int min_cost_flow(int s, int t, int f){",
            "    int res = 0;",
            "    while(f > 0){",
            "        //ベルマンフォード法により、s-t間最短路を求める",
            "        fill(dist, dist + V, INF);",
            "        dist[s] = 0;",
            "        bool update = true;",
            "        while(update){",
            "            update = false;",
            "            for(int v = 0; v < V; v++){",
            "                if(dist[v] == INF) continue;",
            "                for(int i = 0; i < G[v].size(); i++){",
            "                    edge &e = G[v][i];",
            "                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){",
            "                        dist[e.to] = dist[v] + e.cost;",
            "                        prevv[e.to] = v;",
            "                        preve[e.to] = i;",
            "                        update = true;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        ",
            "        if(dist[t] == INF){",
            "            //これ以上流せない",
            "            return -1;",
            "        }",
            "",
            "        //s-t間最短路に沿って目一杯流す",
            "        int d = f;",
            "        for(int v = t; v != s; v = prevv[v]){",
            "            d = min(d, G[prevv[v]][preve[v]].cap);",
            "        }",
            "        f -= d;",
            "        res += d * dist[t];",
            "        for(int v = t; v != s; v = prevv[v]){",
            "            edge &e = G[prevv[v]][preve[v]];",
            "            e.cap -= d;",
            "            G[v][e.rev].cap += d;",
            "        }",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "min_cost_flow(bellman_ford)"
    },
    "TopologicalSort":{
        "prefix": "TopologicalSort",
        "body": [
            "vector<int> Tsort(vector<vector<int>> & G){",
            "    vector<int> To; //トポロジカルソート後のグラフ",
            "    // To.size() == V であればトポロジカルソートができた、そうでなければできなかったと判定できる",
            "    int V = G.size();",
            "    stack<int> st; //入次数が 0 の頂点の集合",
            "    int indeg[V] = {}; //頂点の入次数を管理する配列",
            "    for(int i = 0; i < V; i++){",
            "        for(int j = 0; j < G[i].size(); j++){",
            "            indeg[G[i][j]]++;",
            "        }",
            "    }",
            "    for(int i = 0; i < V; i++){",
            "        if(indeg[i] == 0){",
            "            st.push(i);",
            "        }",
            "    }",
            "    while(!st.empty()){",
            "        int u = st.top();",
            "        st.pop();",
            "        To.push_back(u);",
            "        for(int i = 0; i < G[u].size(); i++){",
            "            indeg[G[u][i]]--; //隣接する頂点の入次数を1減らす",
            "            if(indeg[G[u][i]] == 0){",
            "                st.push(G[u][i]); //入次数が 0 になればstに追加",
            "            }",
            "        }",
            "    }",
            "    return To;",
            "}"
        ],
        "description": "TopologicalSort"
    },
    "Warshall_Floyd":{
        "prefix": "Warshall_Floyd",
        "body": [
            "/*",
            "    辺が存在しない場合、dist[i][j] = INF、ただしdist[i][i] = 0 とする",
            "    頂点数 V のとき : ",
            "    vector<vector<int>> dist(V, vector<int>(V, INF));",
            "    for(int i = 0; i < V; i++){",
            "        dist[i][i] = 0;",
            "    }",
            "*/",
            "template <typename T>",
            "void Warshall_Floyd(vector<vector<T>> & dist){",
            "    int V = dist.size();",
            "    for(int k = 0; k < V; k++){",
            "        for(int i = 0; i < V; i++){",
            "            for(int j = 0; j < V; j++){",
            "                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);",
            "            }",
            "        }",
            "    }",
            "    // dist[i][i] < 0 が存在 <-> 負の閉路が存在",
            "}"
        ],
        "description": "Warshall_Floyd"
    },
    "divisor":{
        "prefix": "divisor",
        "body": [
            "vector<long long> divisor(long long n){",
            "    vector<long long> res;",
            "    for(int i = 1; (long long)i * i <= n; i++){",
            "        if(n % i == 0){",
            "            res.push_back(i);",
            "            if(i != n / i) res.push_back(n / i);",
            "        }",
            "    }",
            "    sort(begin(res), end(res));",
            "    return res;",
            "}"
        ],
        "description": "divisor"
    },
    "eratos":{
        "prefix": "eratos",
        "body": [
            "#define MAX_N 1000000",
            "",
            "int prime[MAX_N];//i番目の素数",
            "bool is_prime[MAX_N + 1];//is_prime[i]がtrueならiは素数",
            "",
            "//n以下の素数の数を返す",
            "int eratos(int n){",
            "    int p = 0;",
            "    for(int i = 0; i <= n; i++) is_prime[i] = true;",
            "    is_prime[0] = is_prime[1] = false;",
            "    for(int i = 2; i <= n; i++){",
            "        if(is_prime[i]){",
            "            prime[p++] = i;",
            "            for(int j = 2 * i; j <= n; j += i) is_prime[j] = false;",
            "        }",
            "    }",
            "    return p;",
            "}"
        ],
        "description": "eratos"
    },
    "GCD":{
        "prefix": "GCD",
        "body": [
            "long long GCD(long long m,long long n){",
            "    if(n == 0) return m;",
            "    else return GCD(n,m % n);",
            "}"
        ],
        "description": "GCD"
    },
    "LCM":{
        "prefix": "LCM",
        "body": [
            "long long LCM(long long m,long long n){",
            "    long long g = GCD(m,n);",
            "    return m / g * n;",
            "}"
        ],
        "description": "LCM"
    },
    "matrix":{
        "prefix": "matrix",
        "body": [
            "//行列は二次元vectorを用いるようにする",
            "typedef vector<int> vec;",
            "typedef vector<vec> mat;",
            "",
            "//A*Bの計算",
            "mat mul(mat &A, mat &B){",
            "    mat C(A.size(), vec(B[0].size()));",
            "    for(int i = 0; i < A.size(); i++){",
            "        for(int k = 0; k < B.size(); k++){",
            "            for(int j = 0; j < B[0].size(); j++){",
            "                C[i][j] = (C[i][j] + A[i][k] * B[k][j]);",
            "            }",
            "        }",
            "    }",
            "    return C;",
            "}",
            "",
            "//A^nの計算",
            "mat pow(mat A, long long n){",
            "    mat B(A.size(), vec(A.size()));",
            "    for(int i = 0; i < A.size(); i++){",
            "        B[i][i] = 1;",
            "    }",
            "    while(n > 0){//繰り返し二乗法",
            "        if(n & 1) B = mul(B, A);",
            "        A = mul(A, A);",
            "        n >>= 1;",
            "    }",
            "    return B;",
            "}"
        ],
        "description": "matrix"
    },
    "MODcomb":{
        "prefix": "MODcomb",
        "body": [
            "#define MAX 100000",
            "",
            "long long fac[MAX], finv[MAX], inv[MAX];",
            "",
            "//テーブルを作る前処理",
            "void COMinit() {",
            "    fac[0] = fac[1] = 1;",
            "    finv[0] = finv[1] = 1;",
            "    inv[1] = 1;",
            "    for(int i = 2; i < MAX; i++){",
            "        fac[i] = fac[i - 1] * i % MOD;",
            "        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;",
            "        finv[i] = finv[i - 1] * inv[i] % MOD;",
            "    }",
            "}",
            "",
            "//二項係数計算",
            "long long COM(int n, int k){",
            "    if(n < k) return 0;",
            "    if(n < 0 || k < 0) return 0;",
            "    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
            "}"
        ],
        "description": "MODcomb"
    },
    "MODinv":{
        "prefix": "MODinv",
        "body": [
            "long long MODinv(long long a){//a ÷ b mod. MOD の求め方 : a * modinv(b) % MOD",
            "    long long b = MOD, u = 1, v = 0;",
            "    while(b){",
            "        long long t = a / b;",
            "        a -= t * b;",
            "        swap(a, b);",
            "        u -= t * v;",
            "        swap(u, v);",
            "    }",
            "    u %= MOD;",
            "    if(u < 0) u += MOD;",
            "    return u;",
            "}"
        ],
        "description": "MODinv"
    },
    "MODpow":{
        "prefix": "MODpow",
        "body": [
            "long long MODpow(long long a, long long n){",
            "    long long res = 1;",
            "    while(n > 0){",
            "        if(n & 1) res = res * a % MOD;",
            "        a = a * a % MOD;",
            "        n >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "MODpow"
    },
    "PrimeFactor":{
        "prefix": "PrimeFactor",
        "body": [
            "map<long long,int> PrimeFactor(long long n){",
            "    map<long long,int> mp;",
            "    for(int i = 2; (long long)i * i <= n; i++){",
            "        while(n % i == 0){",
            "            mp[i]++;",
            "            n /= i;",
            "        }",
            "    }",
            "    if(n != 1) mp[n]++;",
            "    return mp;",
            "}"
        ],
        "description": "PrimeFactor"
    },
    "SegmentEratos":{
        "prefix": "SegmentEratos",
        "body": [
            "bool is_prime[MAX_L];",
            "bool is_prime_small[MAX_SQRT_B];",
            "",
            "//[a,b)の整数に対して篩を行う。is_prime[i - a] = true ⇔ iが素数",
            "void SegmentEratos(long long a, long long b){",
            "    for(int i = 0; (long long)i * i < b; i++) is_prime_small[i] = true;",
            "    for(int i = 0; i < b - a; i++) is_prime[i] = true;",
            "",
            "    for(int i = 2; (long long)i * i < b; i++){",
            "        if(is_prime_small[i]){",
            "            for(int j = 2 * i; (long long)j * j < b; j += i) is_prime_small[j] = false;",
            "            for(long long j = max(2LL, (a + i - 1) / i) * i; j < b; j += i) is_prime[j - a] = false;",
            "        }",
            "    }",
            "}"
        ],
        "description": "SegmentEratos"
    },
    "SOD":{
        "prefix": "SOD",
        "body": [
            "long long SOD(long long n){",
            "    long long sum = 0;",
            "    while(n > 0){",
            "        sum += n % 10;",
            "        n /= 10;",
            "    }",
            "    return sum;",
            "}"
        ],
        "description": "SOD"
    },
    "compress":{
        "prefix": "compress",
        "body": [
            "/*",
            "    https://github.com/beet-aizu/library/blob/master/tools/compress.cpp",
            "    vector<long long> a(n) を座圧する場合 : ",
            "    auto v = compress(a);",
            "    auto m = dict(v);",
            "    i番目の要素の取り出し方 : ",
            "    m[a[i]]",
            "*/",
            "template<typename T>",
            "vector<T> compress(vector<T> vec){//ソートしてユニークを取ったvectorを返す",
            "    sort(vec.begin(), vec.end());",
            "    vec.erase(unique(vec.begin(), vec.end()), vec.end());",
            "    return vec;",
            "}",
            "",
            "template<typename T>",
            "map<T, int> dict(vector<T> & vec){//座圧する",
            "    map<T, int> res;",
            "    for(int i = 0; i < (int)vec.size(); i++){",
            "        res[vec[i]] = i;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "compress"
    },
    "main":{
        "prefix": "main",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define REP(i,a) for(int i = 0; i < (a); i++)",
            "#define ALL(a) (a).begin(),(a).end()",
            "typedef long long ll;",
            "typedef pair<int, int> P;",
            "const int INF = 1e9;",
            "const long long LINF = 1e18;",
            "const long long MOD = 1e9 + 7;",
            "",
            "signed main(){",
            "    $1",
            "    return 0;",
            "}"
        ],
        "description": "main"
    },
    "REP":{
        "prefix": "REP",
        "body": [
            "REP($1,$2){",
            "    $3",
            "}"
        ],
        "description": "REP"
    }
}